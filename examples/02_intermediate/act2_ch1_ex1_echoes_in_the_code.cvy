/**
 * @file act2_ch1_ex1_echoes_in_the_code.cvy
 * @brief Chronovyan Example: Recursive Data Processing
 * @difficulty Intermediate
 * @concepts Recursion, Base Cases, Recursive Steps, Data Structures
 *
 * This example demonstrates recursion techniques in Chronovyan,
 * showing how to process nested data structures using recursive patterns,
 * identify base cases, implement recursive steps, and build practical
 * recursive algorithms for data traversal and transformation.
 *
 * @copyright Chronovyan Project
 */

// Import the standard Chronovyan library
import stdlib.chronovyan;
import stdlib.data.structures;

// Created as part of Side Quest 1 for Act II, Chapter 1

//===============================================================
// Utility Functions
//===============================================================

/**
 * Prints a formatted section header
 * @param title The title of the section
 */
define_pattern print_section_header(title: String) {
    print("\n========== " + title + " ==========\n");
}

//===============================================================
// Part 1: Understanding Recursive Structures
//===============================================================

print_section_header("Simple Recursive Structure Traversal");

/**
 * A simple Temporal Echo structure (nested data)
 * Represents timeline fragments stored in the Chronovyan archives
 */
CONF simple_echo = {
    id: "Echo-Root",
    timestamp: 2500.03,
    data: "Base timeline reference point",
    sub_echoes: [
        {
            id: "Echo-1",
            timestamp: 2500.15,
            data: "First branch event",
            sub_echoes: []
        },
        {
            id: "Echo-2",
            timestamp: 2500.22,
            data: "Second branch event",
            sub_echoes: [
                {
                    id: "Echo-2-1",
                    timestamp: 2500.25,
                    data: "Sub-branch event",
                    sub_echoes: []
                }
            ]
        }
    ]
};

/**
 * Recursively prints the ID of each echo in the structure
 * @param echo The temporal echo to process
 * @param indent The indentation level (for pretty printing)
 */
define_pattern print_echo_ids(echo, indent: Integer = 0) {
    // Create indentation for hierarchy visualization
    CONF indent_str = "";
    for (CONF i = 0; i < indent; i++) {
        indent_str += "  ";
    }
    
    // Print the current echo's ID with appropriate indentation
    print(indent_str + echo.id);
    
    // Base case: If there are no sub-echoes, we're done with this branch
    if (echo.sub_echoes.length == 0) {
        return;
    }
    
    // Recursive step: Process each sub-echo with increased indentation
    for (CONF sub_echo in echo.sub_echoes) {
        print_echo_ids(sub_echo, indent + 1);
    }
}

// Call the recursive function with our root echo
print("Echoes in this Temporal Structure:");
print_echo_ids(simple_echo);

//===============================================================
// Part 2: Collecting Data from Nested Structures
//===============================================================

print_section_header("Collecting Data from Recursive Structures");

/**
 * Recursively collects all data points from the Temporal Echo structure
 * @param echo The temporal echo to process
 * @return An array containing all data points from this echo and its sub-echoes
 */
define_pattern collect_all_data(echo) {
    // Initialize an array to hold all data from this echo and its sub-echoes
    CONF all_data = [];
    
    // Add this echo's data
    all_data.push(echo.data);
    
    // Base case: If there are no sub-echoes, return just this echo's data
    if (echo.sub_echoes.length == 0) {
        return all_data;
    }
    
    // Recursive step: Collect data from each sub-echo and add it to our array
    for (CONF sub_echo in echo.sub_echoes) {
        CONF sub_data = collect_all_data(sub_echo);
        
        // Add all data from the sub-echo to our collection
        for (CONF data_point in sub_data) {
            all_data.push(data_point);
        }
    }
    
    return all_data;
}

// Call the function and display the results
CONF collected_data = collect_all_data(simple_echo);
print("All data collected from Temporal Echo:");
for (CONF i = 0; i < collected_data.length; i++) {
    print("  " + (i + 1) + ". " + collected_data[i]);
}

//===============================================================
// Part 3: Calculating Values from Recursive Structures
//===============================================================

print_section_header("Calculating Values from Recursive Structures");

/**
 * Recursively finds the latest timestamp in the Temporal Echo structure
 * @param echo The temporal echo to process
 * @return The latest timestamp found in this echo or any of its sub-echoes
 */
define_pattern find_latest_timestamp(echo) {
    // Start with this echo's timestamp
    CONF latest = echo.timestamp;
    
    // Base case: If there are no sub-echoes, return this echo's timestamp
    if (echo.sub_echoes.length == 0) {
        return latest;
    }
    
    // Recursive step: Check each sub-echo
    for (CONF sub_echo in echo.sub_echoes) {
        CONF sub_latest = find_latest_timestamp(sub_echo);
        
        // Update our latest timestamp if we found a later one
        if (sub_latest > latest) {
            latest = sub_latest;
        }
    }
    
    return latest;
}

// Call the function and display the result
CONF latest_time = find_latest_timestamp(simple_echo);
print("Latest timestamp in the Temporal Echo: " + latest_time);

// Let's also find the earliest timestamp for comparison
define_pattern find_earliest_timestamp(echo) {
    // Start with this echo's timestamp
    CONF earliest = echo.timestamp;
    
    // Base case: If there are no sub-echoes, return this echo's timestamp
    if (echo.sub_echoes.length == 0) {
        return earliest;
    }
    
    // Recursive step: Check each sub-echo
    for (CONF sub_echo in echo.sub_echoes) {
        CONF sub_earliest = find_earliest_timestamp(sub_echo);
        
        // Update our earliest timestamp if we found an earlier one
        if (sub_earliest < earliest) {
            earliest = sub_earliest;
        }
    }
    
    return earliest;
}

CONF earliest_time = find_earliest_timestamp(simple_echo);
print("Earliest timestamp in the Temporal Echo: " + earliest_time);
print("Temporal span of echoes: " + (latest_time - earliest_time).toFixed(2) + " units");

//===============================================================
// Part 4: Working with Complex Recursive Structures
//===============================================================

print_section_header("Complex Recursive Structures");

/**
 * Definition for a more complex Temporal Echo structure
 * Includes additional metadata and properties
 */
define_structure ComplexEcho {
    id: String,              // Unique identifier
    timestamp: Float,        // Temporal coordinate
    stability: Float,        // Timeline stability (0-1)
    data: String,            // Contained information
    tags: [String],          // Metadata tags
    sub_echoes: [ComplexEcho] // Recursive: contains more echoes
}

/**
 * Create a complex echo instance representing mountain paths
 * This data structure contains information about different possible
 * routes up the temporal mountain, with nested data about specific
 * features, hazards, and conditions along each path.
 */
CONF complex_echo = {
    id: "CR-Root",
    timestamp: 3720.05,
    stability: 0.95,
    data: "Mountain base timeline anchor",
    tags: ["mountain", "anchor", "stable"],
    sub_echoes: [
        {
            id: "CR-East",
            timestamp: 3720.15,
            stability: 0.82,
            data: "Eastern path temporal conditions",
            tags: ["eastern", "path", "unstable"],
            sub_echoes: [
                {
                    id: "CR-East-1",
                    timestamp: 3720.18,
                    stability: 0.67,
                    data: "Eastern path anomaly cluster",
                    tags: ["anomaly", "hazard", "unstable"],
                    sub_echoes: []
                },
                {
                    id: "CR-East-2",
                    timestamp: 3720.22,
                    stability: 0.73,
                    data: "Eastern path safe passage",
                    tags: ["passage", "safe", "narrow"],
                    sub_echoes: []
                }
            ]
        },
        {
            id: "CR-West",
            timestamp: 3720.12,
            stability: 0.88,
            data: "Western path temporal conditions",
            tags: ["western", "path", "stable"],
            sub_echoes: [
                {
                    id: "CR-West-1",
                    timestamp: 3720.14,
                    stability: 0.91,
                    data: "Western path resource cache",
                    tags: ["resource", "cache", "valuable"],
                    sub_echoes: []
                }
            ]
        },
        {
            id: "CR-North",
            timestamp: 3720.08,
            stability: 0.79,
            data: "Northern path temporal conditions",
            tags: ["northern", "path", "moderate"],
            sub_echoes: []
        }
    ]
};

/**
 * Print a summary of the complex echo structure
 */
print("Complex Echo Structure Summary:");
print("Root: " + complex_echo.id + " - " + complex_echo.data);
print("Main branches: " + complex_echo.sub_echoes.length);
for (CONF path in complex_echo.sub_echoes) {
    print("  - " + path.id + ": " + path.data + " (Stability: " + path.stability.toFixed(2) + ")");
    print("    Sub-branches: " + path.sub_echoes.length);
}

/**
 * Recursively find echoes with a specific tag
 * @param echo The temporal echo to search within
 * @param search_tag The tag to search for
 * @return An array of echoes that contain the specified tag
 */
define_pattern find_echoes_with_tag(echo, search_tag) {
    CONF matching_echoes = [];
    
    // Check if this echo has the tag we're looking for
    for (CONF tag in echo.tags) {
        if (tag == search_tag) {
            matching_echoes.push(echo);
            break;
        }
    }
    
    // Base case: If there are no sub-echoes, return our results so far
    if (echo.sub_echoes.length == 0) {
        return matching_echoes;
    }
    
    // Recursive step: Search each sub-echo
    for (CONF sub_echo in echo.sub_echoes) {
        CONF sub_matches = find_echoes_with_tag(sub_echo, search_tag);
        
        // Add all matches from the sub-echo to our collection
        for (CONF match in sub_matches) {
            matching_echoes.push(match);
        }
    }
    
    return matching_echoes;
}

// Search for echoes with specific tags
CONF safe_paths = find_echoes_with_tag(complex_echo, "safe");
CONF hazards = find_echoes_with_tag(complex_echo, "hazard");
CONF resources = find_echoes_with_tag(complex_echo, "resource");

// Display the results
print("\nSafe passages found:");
for (CONF echo in safe_paths) {
    print("  - " + echo.id + ": " + echo.data + " (Stability: " + echo.stability.toFixed(2) + ")");
}

print("\nHazards detected:");
for (CONF echo in hazards) {
    print("  - " + echo.id + ": " + echo.data + " (Stability: " + echo.stability.toFixed(2) + ")");
}

print("\nResource locations:");
for (CONF echo in resources) {
    print("  - " + echo.id + ": " + echo.data + " (Stability: " + echo.stability.toFixed(2) + ")");
}

//===============================================================
// Part 5: Advanced Recursive Data Processing
//===============================================================

print_section_header("Advanced Recursive Analysis");

/**
 * Calculate the stability metrics for a temporal echo and all its sub-echoes
 * @param echo The temporal echo to analyze
 * @return Object containing total_stability and count for averaging
 */
define_pattern calculate_path_stability(echo) {
    // Base case: If this echo has no sub-echoes, return its stability
    if (echo.sub_echoes.length == 0) {
        return {
            total_stability: echo.stability,
            count: 1,
            min_stability: echo.stability,
            max_stability: echo.stability
        };
    }
    
    // Start with this echo's stability
    CONF result = {
        total_stability: echo.stability,
        count: 1,
        min_stability: echo.stability,
        max_stability: echo.stability
    };
    
    // Recursive step: Add the stability from all sub-echoes
    for (CONF sub_echo in echo.sub_echoes) {
        CONF sub_result = calculate_path_stability(sub_echo);
        
        // Update our aggregated metrics
        result.total_stability += sub_result.total_stability;
        result.count += sub_result.count;
        
        // Update min/max stability if needed
        if (sub_result.min_stability < result.min_stability) {
            result.min_stability = sub_result.min_stability;
        }
        if (sub_result.max_stability > result.max_stability) {
            result.max_stability = sub_result.max_stability;
        }
    }
    
    return result;
}

// Calculate stability for each major path
print("Analyzing path stability:");

// Get the major paths (first level of sub-echoes)
CONF paths = complex_echo.sub_echoes;
CONF path_stabilities = [];

for (CONF path in paths) {
    CONF stability_data = calculate_path_stability(path);
    CONF avg_stability = stability_data.total_stability / stability_data.count;
    
    path_stabilities.push({
        id: path.id,
        name: path.data,
        average_stability: avg_stability,
        min_stability: stability_data.min_stability,
        max_stability: stability_data.max_stability,
        stability_range: stability_data.max_stability - stability_data.min_stability
    });
    
    print("  - " + path.id + ":");
    print("      Average stability: " + avg_stability.toFixed(2));
    print("      Min stability: " + stability_data.min_stability.toFixed(2));
    print("      Max stability: " + stability_data.max_stability.toFixed(2));
    print("      Stability range: " + (stability_data.max_stability - stability_data.min_stability).toFixed(2));
}

/**
 * Find the optimal path based on stability criteria
 * Different expedition strategies might prioritize different aspects of stability
 */
print("\nPath recommendations based on different criteria:");

// Find the most stable path on average
CONF most_stable_path = path_stabilities[0];
for (CONF i = 1; i < path_stabilities.length; i++) {
    if (path_stabilities[i].average_stability > most_stable_path.average_stability) {
        most_stable_path = path_stabilities[i];
    }
}

print("Best average stability: " + most_stable_path.id + " - " + most_stable_path.name);
print("  Average stability rating: " + most_stable_path.average_stability.toFixed(2));

// Find the path with the highest minimum stability (most consistently stable)
CONF most_consistent_path = path_stabilities[0];
for (CONF i = 1; i < path_stabilities.length; i++) {
    if (path_stabilities[i].min_stability > most_consistent_path.min_stability) {
        most_consistent_path = path_stabilities[i];
    }
}

print("Most consistently stable: " + most_consistent_path.id + " - " + most_consistent_path.name);
print("  Minimum stability rating: " + most_consistent_path.min_stability.toFixed(2));

// Find the path with the smallest stability range (least variable)
CONF least_variable_path = path_stabilities[0];
for (CONF i = 1; i < path_stabilities.length; i++) {
    if (path_stabilities[i].stability_range < least_variable_path.stability_range) {
        least_variable_path = path_stabilities[i];
    }
}

print("Least variable stability: " + least_variable_path.id + " - " + least_variable_path.name);
print("  Stability range: " + least_variable_path.stability_range.toFixed(2));

//===============================================================
// Part 6: Demonstrating Recursive Power with Depth-First Search
//===============================================================

print_section_header("Advanced Recursive Application: Path Finding");

/**
 * Recursively searches for a path from the root to an echo with a specific ID
 * @param echo The current echo in the search
 * @param target_id The ID we're searching for
 * @param current_path The path traversed so far
 * @return The complete path if found, or null if not found
 */
define_pattern find_path_to_echo(echo, target_id, current_path = []) {
    // Add the current echo to our path
    CONF path = current_path.slice(); // Create a copy of the current path
    path.push(echo.id);
    
    // If we found our target, return the path
    if (echo.id == target_id) {
        return path;
    }
    
    // Base case: If there are no sub-echoes, this branch is a dead end
    if (echo.sub_echoes.length == 0) {
        return null;
    }
    
    // Recursive step: Try each sub-echo
    for (CONF sub_echo in echo.sub_echoes) {
        CONF result = find_path_to_echo(sub_echo, target_id, path);
        
        // If we found a path in this branch, return it
        if (result != null) {
            return result;
        }
    }
    
    // If we get here, we didn't find the target in any branch
    return null;
}

// Find paths to specific echoes
CONF target_ids = ["CR-East-2", "CR-West-1", "Echo-Not-Found"];

for (CONF target_id in target_ids) {
    CONF path = find_path_to_echo(complex_echo, target_id);
    
    if (path != null) {
        print("Path to " + target_id + ":");
        print("  " + path.join(" â†’ "));
    } else {
        print("No path found to " + target_id);
    }
}

//===============================================================
// Conclusion: The Power of Recursion
//===============================================================

print_section_header("Conclusion");

print("Recursion is a powerful technique for processing nested data structures.");
print("Key benefits demonstrated in this example:");
print("  1. Elegant traversal of hierarchical data");
print("  2. Natural expression of divide-and-conquer algorithms");
print("  3. Simplified code for complex data processing tasks");
print("  4. Effective solution for problems with self-similar structure");
print("\nWith these recursive techniques, you can now effectively process");
print("the Temporal Echoes and extract the critical information needed");
print("for your ascent up the mountain to find Professor Thorne."); 