{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"\u23f3 Chronovyan <p>A C++ temporal programming language for time-aware applications</p> <p>              Get Started                       View Examples          </p>"},{"location":"#features","title":"\ud83d\ude80 Features","text":"- **Temporal Programming**   - First-class time types and operations   - Native support for temporal logic   - Deterministic execution model  - **Resource Management**   - Built-in tracking of temporal resources   - Efficient `Chronon` and `Aethel` management   - Predictable resource allocation  - **Powerful Type System**   - Static typing with type inference   - Temporal type safety   - Extensible type system"},{"location":"#quick-start","title":"\ud83d\udcd6 Quick Start","text":"<ol> <li> <p>Build Chronovyan <pre><code># Clone the repository\ngit clone https://github.com/Chronovyan/Chronovyan.git\ncd Chronovyan\n\n# Configure and build\nmkdir build &amp;&amp; cd build\ncmake ..\nmake\n</code></pre></p> </li> <li> <p>Your First Chronovyan Program <pre><code>// hello_world.cvy\nMODULE hello_world;\n\nIMPORT std.io;\n\nFUNC VOID main() {\n    io::println(\"Hello, Chronovyan!\");\n\n    // Basic temporal operation\n    DECLARE CONF::STATIC start_time = NOW();\n    DELAY 1.0s;  // Wait for 1 second\n    DECLARE CONF::STATIC end_time = NOW();\n\n    io::println(\"Elapsed: \", (end_time - start_time), \" seconds\");\n}\n</code></pre></p> </li> <li> <p>Explore the Documentation</p> </li> <li>Installation Guide</li> <li>Language Reference</li> <li>Examples</li> </ol>"},{"location":"#chronovyan-temporal-programming-redefined","title":"Chronovyan: Temporal Programming Redefined","text":"<p>Chronovyan is a statically-typed, temporal programming language designed for building robust and efficient time-aware applications. It introduces first-class concepts of time, temporal resources, and timeline management, making it ideal for simulations, event-driven systems, and any application where time is a critical component.</p>"},{"location":"#core-philosophy","title":"Core Philosophy","text":"<p>Chronovyan is built around the concept of Temporal Programming, where time is a first-class citizen. The language is designed with two fundamental principles:</p> <ol> <li>Order (Conformity): For stability and predictability</li> <li>Flux (Rebellion): For dynamic adaptation and temporal manipulation</li> </ol>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Temporal Types: Native support for time points, durations, and intervals</li> <li>Resource Management: Built-in tracking of temporal resources (<code>Chronon</code> and <code>Aethel</code>)</li> <li>Deterministic Execution: Predictable behavior for time-dependent operations</li> <li>Concurrency Model: Safe and efficient handling of temporal concurrency</li> <li>Type Safety: Strong static typing with type inference</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide</li> <li>Quick Start</li> <li>Examples</li> </ul>"},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>Temporal Programming</li> <li>Resource Management</li> <li>Concurrency Model</li> </ul>"},{"location":"#language-reference","title":"Language Reference","text":"<ul> <li>Language Specification</li> <li>API Reference</li> <li>API Reference</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Contributing</li> <li>GitHub Repository</li> <li>Roadmap</li> </ul>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Discussions</li> </ul>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":"<ul> <li>Game Development: Manage game loops, animations, and timed events</li> <li>Simulations: Model complex temporal systems</li> <li>Data Processing: Schedule and coordinate data pipelines</li> <li>Interactive Applications: Create responsive UIs with timed interactions</li> </ul>"},{"location":"#why-chronovyan","title":"\ud83c\udf1f Why Chronovyan?","text":"<ul> <li>Intuitive API: Designed to be easy to use and understand</li> <li>Flexible: Suitable for a wide range of applications</li> <li>Well-documented: Comprehensive guides and API reference</li> <li>Active Development: Regular updates and improvements</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<p>Explore the documentation to learn more about Chronovyan:</p> <ul> <li>Getting Started - Set up Chronovyan and take your first steps</li> <li>Examples - Practical examples and use cases</li> <li>API Reference - Comprehensive API documentation</li> <li>Contributing - How to contribute to Chronovyan</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions from the community! Whether you're fixing bugs, adding new features, or improving documentation, your help is appreciated.</p> <p>Learn how to contribute \u2192</p>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>Chronovyan is licensed under the MIT License.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Chronovyan","text":"<p>Thank you for your interest in contributing to Chronovyan! We welcome all contributions, whether they're bug reports, feature requests, documentation improvements, or code contributions.</p>"},{"location":"CONTRIBUTING/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Fork the repository on GitHub</li> <li>Clone your fork locally</li> <li>Create a branch for your changes</li> <li>Make your changes</li> <li>Test your changes</li> <li>Commit your changes with a clear commit message</li> <li>Push to your fork</li> <li>Open a Pull Request</li> </ol>"},{"location":"CONTRIBUTING/#development-setup","title":"Development Setup","text":""},{"location":"CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8+</li> <li>pip</li> <li>Git</li> </ul>"},{"location":"CONTRIBUTING/#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/yourusername/Chronovyan.github.io.git\ncd Chronovyan.github.io\n\n# Install dependencies\npip install -r requirements.txt\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the Documentation","text":"<pre><code># Serve the documentation locally\nmkdocs serve\n\n# Build the documentation\nmkdocs build\n</code></pre>"},{"location":"CONTRIBUTING/#code-style","title":"Code Style","text":"<p>Please follow the existing code style in the project. We use:</p> <ul> <li>Black for code formatting</li> <li>PEP 8 for Python code style</li> </ul>"},{"location":"CONTRIBUTING/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting issues, please include:</p> <ol> <li>A clear title and description</li> <li>Steps to reproduce the issue</li> <li>Expected vs. actual behavior</li> <li>Any relevant error messages</li> </ol>"},{"location":"CONTRIBUTING/#feature-requests","title":"Feature Requests","text":"<p>We welcome feature requests! Please open an issue and describe:</p> <ol> <li>The feature you'd like to see</li> <li>Why it's useful</li> <li>Any implementation ideas (optional)</li> </ol>"},{"location":"CONTRIBUTING/#license","title":"License","text":"<p>By contributing to Chronovyan, you agree that your contributions will be licensed under the project's LICENSE file.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#timeline","title":"Timeline","text":"<pre><code>class Timeline:\n    \"\"\"A sequence of events that occur over time.\n\n    The Timeline class allows you to schedule events to occur at specific times\n    or after specific delays, and then run them in the correct order.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize a new, empty timeline.\"\"\"\n        ...\n\n    def add_event(self, event: 'Event', delay: float = 0.0) -&gt; None:\n        \"\"\"Add an event to the timeline.\n\n        Args:\n            event: The event to add\n            delay: Number of seconds to wait before the event occurs\n        \"\"\"\n        ...\n\n    def run(self, max_time: Optional[float] = None) -&gt; None:\n        \"\"\"Run the timeline, executing events in order.\n\n        Args:\n            max_time: Maximum time to run the timeline (in seconds).\n                     If None, runs until all events are processed.\n        \"\"\"\n        ...\n\n    def pause(self) -&gt; None:\n        \"\"\"Pause the timeline.\"\"\"\n        ...\n\n    def resume(self) -&gt; None:\n        \"\"\"Resume a paused timeline.\"\"\"\n        ...\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the timeline immediately.\"\"\"\n        ...\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Check if the timeline is currently running.\"\"\"\n        ...\n\n    @property\n    def current_time(self) -&gt; float:\n        \"\"\"Get the current simulation time (in seconds since start).\"\"\"\n        ...\n\nclass Event:\n    \"\"\"An event that can be scheduled on a timeline.\n\n    Args:\n        name: A name for the event (for debugging and logging)\n        data: Optional data to associate with the event\n        on_trigger: Optional callback function to call when the event is triggered\n        delay: Optional delay in seconds before the event occurs\n    \"\"\"\n\n    def __init__(self, name: str, data: Any = None, \n                 on_trigger: Optional[Callable[['Event'], None]] = None,\n                 delay: float = 0.0):\n        ...\n\n    def trigger(self) -&gt; None:\n        \"\"\"Trigger the event, calling the on_trigger callback if set.\"\"\"\n        ...\n\n    @property\n    def is_triggered(self) -&gt; bool:\n        \"\"\"Check if the event has been triggered.\"\"\"\n        ...\n\n    @property\n    def timestamp(self) -&gt; Optional[float]:\n        \"\"\"Get the time when the event was triggered, or None if not triggered yet.\"\"\"\n        ...\n\n    @property\n    def age(self) -&gt; Optional[float]:\n        \"\"\"Get the time since the event was triggered, or None if not triggered yet.\"\"\"\n        ...\n            The current simulation time in seconds.\n        \"\"\"\n        ...\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Check if the timeline is currently running.\n\n        Returns:\n            True if the timeline is running, False otherwise.\n        \"\"\"\n        ...\n\n### Event\n\n```python\nclass Event:\n    \"\"\"Represents an event that occurs at a specific time.\n\n    Events are the basic building blocks of a timeline. Each event has a timestamp\n    and a callback function that gets called when the event is processed.\n    \"\"\"\n\n    def __init__(self, timestamp: float, callback: Callable, data: Any = None):\n        \"\"\"Initialize a new Event.\n\n        Args:\n            timestamp: When the event should occur (in simulation time).\n            callback: Function to call when the event is processed.\n            data: Optional data to pass to the callback.\n        \"\"\"\n        ...\n\n    def trigger(self) -&gt; None:\n        \"\"\"Trigger the event's callback.\"\"\"\n        ...\n\n    @property\n    def timestamp(self) -&gt; float:\n        \"\"\"Get the event's timestamp.\"\"\"\n        ...\n\n    @property\n    def data(self) -&gt; Any:\n        \"\"\"Get the event's data.\"\"\"\n        ...\n</code></pre>"},{"location":"api/#cli-reference","title":"CLI Reference","text":"<p>Chronovyan provides a command-line interface for basic timeline operations:</p> <pre><code># Show help\nchronovyan --help\n\n# Create and run a simple timeline\nchronovyan run --event \"0.5:print('Hello after 0.5s')\" --event \"1.0:print('Hello after 1.0s')\"\n\n# Run a timeline from a JSON file\nchronovyan run --file timeline.json\n\n# List available commands\nchronovyan --help\n</code></pre>"},{"location":"api/#example-usage","title":"Example Usage","text":""},{"location":"api/#creating-a-timeline","title":"Creating a Timeline","text":"<pre><code>from chronovyan import Timeline, Event\n\ndef callback(data):\n    print(f\"Event triggered with data: {data}\")\n\ntimeline = Timeline()\nevent1 = Event(1.0, callback, \"First event\")\nevent2 = Event(2.0, callback, \"Second event\")\n\ntimeline.add_event(event2)\ntimeline.add_event(event1)  # Events will be processed in timestamp order\n\ntimeline.run()\n</code></pre>"},{"location":"api/#using-dependencies-between-events","title":"Using Dependencies Between Events","text":"<pre><code>from chronovyan import Timeline, Event\n\ndef setup_event(timeline):\n    def callback(data):\n        print(f\"Processing {data}\")\n        # Schedule another event\n        timeline.add_event(Event(timeline.current_time + 1.0, callback, f\"Child of {data}\"))\n\n    return Event(0.0, callback, \"Initial event\")\n\ntimeline = Timeline()\ntimeline.add_event(setup_event(timeline))\ntimeline.run(until=5.0)  # Run for 5 seconds of simulation time\n</code></pre>"},{"location":"api/#type-definitions","title":"Type Definitions","text":""},{"location":"api/#callback-protocol","title":"Callback Protocol","text":"<pre><code>from typing import Protocol, Any, Optional\n\nclass EventCallback(Protocol):\n    def __call__(self, data: Any) -&gt; None:\n        \"\"\"Callback function type for event processing.\n\n        Args:\n            data: The data associated with the event.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/#constants","title":"Constants","text":"<ul> <li><code>VERSION</code>: Current version of the Chronovyan library</li> <li><code>DEFAULT_TIMESTEP</code>: Default time step used for simulation (0.01 seconds)</li> </ul>"},{"location":"api/#exceptions","title":"Exceptions","text":""},{"location":"api/#chronovyanerror","title":"ChronovyanError","text":"<p>Base class for all Chronovyan-specific exceptions.</p>"},{"location":"api/#timelineerror","title":"TimelineError","text":"<p>Raised for errors related to timeline operations.</p>"},{"location":"api/#eventerror","title":"EventError","text":"<p>Raised for errors related to event operations.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/#creating-a-simple-timeline","title":"Creating a Simple Timeline","text":"<pre><code>from chronovyan import Timeline, Event\n\n# Create a callback function that will be called when events are triggered\ndef log_event(event):\n    print(f\"[{timeline.current_time:.2f}s] {event.name}: {event.data}\")\n\n# Create a new timeline\ntimeline = Timeline()\n\n# Create events with names and data\nevent1 = Event(\"first\", \"Hello, Chronovyan!\", on_trigger=log_event)\nevent2 = Event(\"second\", \"This is a test event\", on_trigger=log_event)\n\n# Add events to the timeline with delays (in seconds)\ntimeline.add_event(event1, delay=1.0)  # Trigger after 1 second\ntimeline.add_event(event2, delay=3.0)  # Trigger after 3 seconds\n\n# Run the timeline\ntimeline.run()\n\n# Output:\n# [1.00s] first: Hello, Chronovyan!\n# [3.00s] second: This is a test event\n</code></pre>"},{"location":"examples/#using-event-data-and-callbacks","title":"Using Event Data and Callbacks","text":"<p><pre><code>from chronovyan import Timeline, Event\n\n# Create a timeline\ntimeline = Timeline()\n\n# Define a more complex callback that uses event data\ndef process_event(event):\n    print(f\"[{timeline.current_time:.2f}s] Processing {event.name}\")\n    if event.data:\n        print(f\"  Data: {event.data}\")\n    if event.is_triggered:\n        print(f\"  This event was triggered at {event.timestamp}\")\n\n# Create events with different data and callbacks\nstart_event = Event(\"start\", {\"message\": \"Starting the process\"}, on_trigger=process_event)\nprogress_event = Event(\"progress\", {\"percent\": 50}, on_trigger=process_event)\ncomplete_event = Event(\"complete\", {\"status\": \"success\"}, on_trigger=process_event)\n\n# Schedule the events\ntimeline.add_event(start_event, delay=0.5)      # After 0.5 seconds\ntimeline.add_event(progress_event, delay=2.0)   # After 2 seconds\n# This event will be triggered immediately when the timeline starts\nimmediate_event = Event(\"immediate\", \"This runs right away\", on_trigger=process_event)\ntimeline.add_event(immediate_event)\n\n# Run the timeline for 3 seconds\ntimeline.run(max_time=3.0)\n\n# Output:\n# [0.00s] Processing immediate\n#   Data: This runs right away\n# [0.50s] Processing start\n#   Data: {'message': 'Starting the process'}\n# [2.00s] Processing progress\n#   Data: {'percent': 50}\n</code></pre>     # Event C depends on A and B     def event_c_callback(_):         print(f\"[{timeline.current_time:.2f}s] Event C (depends on A &amp; B)\")</p> <pre><code>event_c = Event(3.0, event_c_callback)\n\ntimeline.add_event(event_a)\ntimeline.add_event(event_b)\ntimeline.add_event(event_c)\n\nreturn timeline\n</code></pre>"},{"location":"examples/#run-the-timeline-with-dependencies","title":"Run the timeline with dependencies","text":"<p>timeline = setup_dependencies() timeline.run() <pre><code>## Advanced Usage\n\n### Event Chaining\n\n```python\nfrom chronovyan import Timeline, Event\n\n# Create a timeline\ntimeline = Timeline()\n\ndef create_chained_events():\n    \"\"\"Create a sequence of events where each triggers the next.\"\"\"\n\n    def create_callback(name, next_event=None):\n        def callback(event):\n            print(f\"[{timeline.current_time:.2f}s] {event.name}: {event.data}\")\n            if next_event and not next_event.is_triggered:\n                next_event.trigger()\n        return callback\n\n    # Create events in reverse order\n    event_c = Event(\"event_c\", \"Third in sequence\", on_trigger=create_callback(\"Third\"))\n    event_b = Event(\"event_b\", \"Second in sequence\", on_trigger=create_callback(\"Second\", event_c))\n    event_a = Event(\"event_a\", \"First in sequence\", on_trigger=create_callback(\"First\", event_b))\n\n    return event_a\n\n# Get the first event in the chain\nfirst_event = create_chained_events()\n\n# Schedule the first event to run after 1 second\ntimeline.add_event(first_event, delay=1.0)\n\n# Run the timeline\ntimeline.run()\n\n# Output:\n# [1.00s] First: First in sequence\n# [1.00s] Second: Second in sequence\n# [1.00s] Third: Third in sequence\n</code></pre></p>"},{"location":"examples/#error-handling-in-events","title":"Error Handling in Events","text":"<pre><code>from chronovyan import Timeline, Event\n\n# Create a timeline\ntimeline = Timeline()\n\ndef error_handler(event, exception):\n    print(f\"Error in {event.name}: {exception}\")\n\ndef risky_operation(event):\n    if \"error\" in str(event.data).lower():\n        raise ValueError(f\"Error processing {event.data}\")\n    print(f\"Successfully processed: {event.data}\")\n\n# Create events with potential errors\nevent1 = Event(\"safe_event\", \"This will work\", on_trigger=risky_operation)\nevent2 = Event(\"error_event\", \"This will cause an error\", on_trigger=risky_operation)\nevent2.on_error = error_handler  # Attach error handler\n\n# Schedule the events\ntimeline.add_event(event1, delay=0.5)\ntimeline.add_event(event2, delay=1.5)\n\n# Run the timeline\ntry:\n    timeline.run()\nexcept Exception as e:\n    print(f\"Timeline stopped due to: {e}\")\n\n# Output:\n# [0.50s] Successfully processed: This will work\n# [1.50s] Error in error_event: Error processing This will cause an error\n</code></pre>"},{"location":"examples/#using-max_time-to-limit-execution","title":"Using max_time to Limit Execution","text":"<pre><code>from chronovyan import Timeline, Event\n\n# Create a timeline\ntimeline = Timeline()\n\ndef periodic_event(event):\n    print(f\"[{timeline.current_time:.2f}s] Periodic event\")\n    # Reschedule this event\n    timeline.add_event(Event(\"periodic\", on_trigger=periodic_event), delay=1.0)\n\n# Start periodic events\ntimeline.add_event(Event(\"start\", on_trigger=periodic_event))\n\n# Run for 3.5 seconds\nprint(\"Running for 3.5 seconds...\")\ntimeline.run(max_time=3.5)\n\n# Output:\n# [0.00s] Periodic event\n# [1.00s] Periodic event\n# [2.00s] Periodic event\n# [3.00s] Periodic event\n# Timeline stopped at 3.50s\n</code></pre>"},{"location":"examples/#periodic-events","title":"Periodic Events","text":"<pre><code>from chronovyan import Timeline, Event\n\ndef create_periodic_printer(timeline, interval, count, prefix):\n    def callback(_):\n        nonlocal count\n        if count &gt; 0:\n            print(f\"[{timeline.current_time:.2f}s] {prefix} {count}\")\n            count -= 1\n            # Schedule the next occurrence\n            timeline.add_event(Event(timeline.current_time + interval, callback, None))\n\n    return callback\n\n# Create a timeline with periodic events\ntimeline = Timeline()\ntimeline.add_event(Event(0.0, create_periodic_printer(timeline, 1.0, 5, \"Tick:\")))\ntimeline.run()\n</code></pre>"},{"location":"examples/#timeout-pattern","title":"Timeout Pattern","text":"<pre><code>from chronovyan import Timeline, Event\n\ndef setup_timeout():\n    timeline = Timeline()\n\n    def on_timeout():\n        print(f\"[{timeline.current_time:.2f}s] Operation timed out!\")\n        timeline.stop()\n\n    def long_running_operation():\n        print(f\"[{timeline.current_time:.2f}s] Starting long operation...\")\n        # Simulate work by scheduling completion after 3 seconds\n        timeline.add_event(Event(timeline.current_time + 3.0, lambda _: print(\"Operation completed!\")))\n\n    # Set a timeout for 2 seconds\n    timeline.add_event(Event(2.0, lambda _: on_timeout()))\n\n    # Start the operation\n    timeline.add_event(Event(0.1, lambda _: long_running_operation()))\n\n    return timeline\n\n# This will time out after 2 seconds\nsetup_timeout().run()\n</code></pre>"},{"location":"examples/#real-world-examples","title":"Real-world Examples","text":""},{"location":"examples/#network-request-simulation","title":"Network Request Simulation","text":"<pre><code>from chronovyan import Timeline, Event\nimport random\n\ndef simulate_network_request(timeline, url, callback):\n    \"\"\"Simulate a network request with random latency.\"\"\"\n    latency = random.uniform(0.1, 2.0)  # Random latency between 0.1 and 2.0 seconds\n\n    def process_response():\n        # Simulate success or failure\n        success = random.random() &gt; 0.3  # 70% success rate\n        if success:\n            response = f\"Response from {url} (took {latency:.2f}s)\"\n        else:\n            response = f\"Error fetching {url} (took {latency:.2f}s)\"\n        callback(response, success)\n\n    # Schedule the response\n    timeline.add_event(Event(timeline.current_time + latency, \n                           lambda _: process_response()))\n\ndef run_requests():\n    timeline = Timeline()\n    urls = [\"https://api.example.com/data/1\",\n            \"https://api.example.com/data/2\",\n            \"https://api.example.com/data/3\"]\n\n    def handle_response(response, success):\n        status = \"\u2713\" if success else \"\u2717\"\n        print(f\"[{timeline.current_time:.2f}s] {status} {response}\")\n\n    # Start all requests at once\n    for url in urls:\n        simulate_network_request(timeline, url, handle_response)\n\n    return timeline\n\n# Run the simulation\nrun_requests().run()\n</code></pre>"},{"location":"examples/#game-loop-simulation","title":"Game Loop Simulation","text":"<p>Here's a complete turn-based game example using Chronovyan's event system:</p> <pre><code>from chronovyan import Timeline, Event\nimport random\n\nclass SimpleGame:\n    def __init__(self):\n        self.timeline = Timeline()\n        self.player_health = 100\n        self.enemy_health = 100\n        self.game_over = False\n\n    def log_status(self):\n        \"\"\"Print the current game status.\"\"\"\n        print(f\"\\n--- Status ---\")\n        print(f\"Player Health: {self.player_health}\")\n        print(f\"Enemy Health: {self.enemy_health}\")\n\n    def player_turn(self, event):\n        \"\"\"Handle the player's turn.\"\"\"\n        if self.game_over:\n            return\n\n        self.log_status()\n        print(\"\\n--- Player's Turn ---\")\n\n        # Player's attack\n        damage = random.randint(5, 15)\n        self.enemy_health -= damage\n        print(f\"You hit the enemy for {damage} damage!\")\n\n        # Check for victory\n        if self.enemy_health &lt;= 0:\n            self.enemy_health = 0\n            self.log_status()\n            print(\"\\n\ud83c\udf89 You defeated the enemy!\")\n            self.game_over = True\n            self.timeline.stop()\n            return\n\n        # Schedule enemy's turn after a delay\n        self.timeline.add_event(\n            Event(\"enemy_turn\", on_trigger=self.enemy_turn),\n            delay=1.5\n        )\n\n    def enemy_turn(self, event):\n        \"\"\"Handle the enemy's turn.\"\"\"\n        if self.game_over:\n            return\n\n        self.log_status()\n        print(\"\\n--- Enemy's Turn ---\")\n\n        # Enemy's attack\n        damage = random.randint(3, 12)\n        self.player_health -= damage\n        print(f\"The enemy hits you for {damage} damage!\")\n\n        # Check for defeat\n        if self.player_health &lt;= 0:\n            self.player_health = 0\n            self.log_status()\n            print(\"\\n\ud83d\udc80 You were defeated!\")\n            self.game_over = True\n            self.timeline.stop()\n            return\n\n        # Schedule player's next turn after a delay\n        self.timeline.add_event(\n            Event(\"player_turn\", on_trigger=self.player_turn),\n            delay=1.5\n        )\n\n    def start(self):\n        \"\"\"Start the game.\"\"\"\n        print(\"=== Simple Combat Game ===\")\n        print(\"Defeat the enemy before they defeat you!\")\n\n        # Start with player's turn\n        self.timeline.add_event(\n            Event(\"start_game\", on_trigger=self.player_turn),\n            delay=1.0\n        )\n\n        # Run the game\n        try:\n            self.timeline.run()\n        except KeyboardInterrupt:\n            print(\"\\nGame stopped by user.\")\n        finally:\n            print(\"\\nThanks for playing!\")\n\n# Start the game\nif __name__ == \"__main__\":\n    game = SimpleGame()\n    game.start()\n</code></pre> <p>This example demonstrates a complete turn-based combat game where: 1. The player and enemy take turns attacking each other 2. Each turn is scheduled with a delay for better readability 3. The game ends when either the player or enemy's health reaches zero 4. Status is displayed after each turn 5. The game can be safely interrupted with Ctrl+C</p>"},{"location":"examples/#performance-considerations","title":"Performance Considerations","text":""},{"location":"examples/#efficient-event-creation","title":"Efficient Event Creation","text":"<p>When creating many events, consider these optimizations:</p> <pre><code># Less efficient: Creating many small callbacks\ndef create_events_slow(timeline, count):\n    for i in range(count):\n        timeline.add_event(Event(\n            i * 0.1,\n            lambda _, i=i: print(f\"Event {i}\")  # Note the i=i to capture the loop variable\n        ))\n\n# More efficient: Batch similar events\ndef create_events_fast(timeline, count):\n    def batch_handler(event_data):\n        for data in event_data:\n            print(f\"Event {data}\")\n\n    # Group events by time and process in batches\n    event_data = [(i * 0.1, i) for i in range(count)]\n    timeline.add_event(Event(0.0, lambda _: batch_handler([d[1] for d in event_data])))\n</code></pre>"},{"location":"examples/#integration-examples","title":"Integration Examples","text":""},{"location":"examples/#using-with-asyncio","title":"Using with asyncio","text":"<pre><code>import asyncio\nfrom chronovyan import Timeline, Event\n\nasync def run_timeline_with_asyncio(timeline):\n    loop = asyncio.get_event_loop()\n\n    def run_timeline():\n        timeline.run()\n\n    # Run the timeline in a thread pool\n    await loop.run_in_executor(None, run_timeline)\n\n# Example usage\nasync def main():\n    timeline = Timeline()\n    timeline.add_event(Event(1.0, lambda _: print(\"Async event!\")))\n\n    # Run other asyncio tasks concurrently\n    await asyncio.gather(\n        run_timeline_with_asyncio(timeline),\n        asyncio.sleep(2.0)\n    )\n\n# Run the asyncio event loop\nasyncio.run(main())\n</code></pre>"},{"location":"concepts/","title":"Core Concepts","text":"<p>Welcome to the core concepts of Chronovyan, a statically-typed temporal programming language. This section covers the fundamental principles that make Chronovyan unique and powerful.</p>"},{"location":"concepts/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Temporal Programming</li> <li>The Great Duality</li> <li>Temporal Resources</li> <li>Resource Management</li> <li>Chronon</li> <li>Aethel</li> <li>Memory Management</li> <li>Performance Considerations</li> </ul>"},{"location":"concepts/#the-great-duality","title":"The Great Duality","text":"<p>Chronovyan is built around two fundamental principles that govern all temporal operations:</p> <ol> <li>Order (Conformity)</li> <li>Stability and predictability</li> <li>Enforced through <code>CONF</code> variables and <code>::STATIC</code> flags</li> <li> <p>Ensures deterministic behavior</p> </li> <li> <p>Flux (Rebellion)</p> </li> <li>Dynamic adaptation and change</li> <li>Enabled by <code>REB</code> variables and <code>::FLUX</code> flags</li> <li>Allows for temporal manipulation</li> </ol>"},{"location":"concepts/#temporal-resources","title":"Temporal Resources","text":""},{"location":"concepts/#chronon","title":"Chronon","text":"<ul> <li>Basic quantum of time</li> <li>Represents discrete moments in the timeline</li> <li>Used for scheduling and ordering events</li> </ul>"},{"location":"concepts/#aethel","title":"Aethel","text":"<ul> <li>Temporal energy resource</li> <li>Consumed by temporal operations</li> <li>Must be managed to prevent paradoxes</li> </ul>"},{"location":"concepts/#memory-management","title":"Memory Management","text":"<p>Chronovyan provides several memory management strategies:</p>"},{"location":"concepts/#performance-considerations","title":"Performance Considerations","text":"<p>When working with Chronovyan, keep these performance considerations in mind:</p> <ol> <li>Static Allocation</li> <li>Fixed at compile-time</li> <li> <p>Most efficient for known sizes</p> </li> <li> <p>Dynamic Allocation</p> </li> <li>Flexible runtime allocation</li> <li> <p>Requires explicit management</p> </li> <li> <p>Pooled Allocation</p> </li> <li>Pre-allocated resource pools</li> <li>Reduces allocation overhead</li> </ol>"},{"location":"concepts/#concurrency-model","title":"Concurrency Model","text":"<p>Chronovyan's concurrency model is designed to handle temporal operations safely and efficiently:</p> <ul> <li>Temporal Threads: Lightweight, cooperative threads</li> <li>Worker Pools: For CPU-bound operations</li> <li>Channels: Thread-safe communication</li> <li>Synchronization Primitives: Locks, barriers, and conditions</li> </ul>"},{"location":"concepts/#getting-started","title":"Getting Started","text":"<p>Ready to dive deeper? Explore the following sections:</p> <ul> <li>Temporal Programming: Learn about time as a first-class citizen</li> <li>Resource Management: Master Chronon and Aethel</li> <li>Concurrency: Understand parallel execution in Chronovyan</li> <li>Locks: Protect shared resources</li> </ul>"},{"location":"concepts/#time-management","title":"Time Management","text":"<p>Chronovyan provides flexible time management:</p> <ul> <li>Wall Time: Real-world time</li> <li>Simulation Time: Virtual time for testing</li> <li>Time Scaling: Speed up or slow down time</li> </ul>"},{"location":"concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Set up Chronovyan</li> <li>API Reference - Detailed API documentation</li> <li>Examples - Practical examples of Chronovyan in action</li> </ul>"},{"location":"concepts/concurrency/","title":"Concurrency in Chronovyan","text":""},{"location":"concepts/concurrency/#overview","title":"Overview","text":"<p>Chronovyan's concurrency model is designed to handle the complexities of temporal programming, providing safe and efficient mechanisms for parallel execution while maintaining temporal consistency.</p>"},{"location":"concepts/concurrency/#threading-model","title":"Threading Model","text":""},{"location":"concepts/concurrency/#1-temporal-threads","title":"1. Temporal Threads","text":"<ul> <li>Lightweight, cooperative threads</li> <li>Scheduled by the runtime</li> <li>Non-preemptive scheduling</li> </ul> <p>Example: <pre><code>// Create a new temporal thread\nLET t1 = SPAWN {\n    // This code runs concurrently\n    FOR i IN 1..10 {\n        PRINT(\"Thread 1: \", i);\n        YIELD;\n    }\n};\n\n// Main thread continues execution\nFOR i IN 1..10 {\n    PRINT(\"Main thread: \", i);\n    YIELD;\n}\n\n// Wait for thread to complete\nAWAIT t1;\n</code></pre></p>"},{"location":"concepts/concurrency/#2-worker-pools","title":"2. Worker Pools","text":"<ul> <li>Fixed-size thread pools</li> <li>For CPU-bound work</li> <li>Managed by the runtime</li> </ul> <p>Example: <pre><code>// Execute work in parallel\nLET results = PARALLEL_MAP(1..100, \\i -&gt; {\n    // Expensive computation\n    RETURN i * i;\n});\n</code></pre></p>"},{"location":"concepts/concurrency/#synchronization-primitives","title":"Synchronization Primitives","text":""},{"location":"concepts/concurrency/#1-temporal-locks","title":"1. Temporal Locks","text":"<ul> <li>Time-aware mutexes</li> <li>Deadlock prevention</li> <li>Timeout support</li> </ul> <p>Example: <pre><code>// Create a temporal lock\nLET lock = NEW_TEMPORAL_LOCK();\n\n// Acquire with timeout\nIF (TRY_LOCK(lock, 1s)) {\n    // Critical section\n    UNLOCK(lock);\n} ELSE {\n    // Handle timeout\n}\n</code></pre></p>"},{"location":"concepts/concurrency/#2-channels","title":"2. Channels","text":"<ul> <li>Thread-safe communication</li> <li>Buffered and unbuffered</li> <li>Select statement support</li> </ul> <p>Example: <pre><code>// Create a channel\nLET ch = NEW_CHANNEL&lt;INT&gt;(10);  // Buffer size 10\n\n// Producer\nSPAWN {\n    FOR i IN 1..10 {\n        SEND(ch, i);\n    }\n    CLOSE(ch);\n};\n\n// Consumer\nFOR VALUE i IN ch {\n    PRINT(\"Received: \", i);\n}\n</code></pre></p>"},{"location":"concepts/concurrency/#temporal-consistency","title":"Temporal Consistency","text":""},{"location":"concepts/concurrency/#1-happens-before-relationship","title":"1. Happens-Before Relationship","text":"<ul> <li>Defines event ordering</li> <li>Ensures consistency</li> <li>Enforced by the runtime</li> </ul>"},{"location":"concepts/concurrency/#2-snapshot-isolation","title":"2. Snapshot Isolation","text":"<ul> <li>Consistent views of data</li> <li>Prevents temporal anomalies</li> <li>Supports nested transactions</li> </ul> <p>Example: <pre><code>// Start a transaction\nBEGIN_TRANSACTION {\n    // Read consistent snapshot\n    LET balance = GET_BALANCE(account_id);\n\n    // Make changes\n    SET_BALANCE(account_id, balance - amount);\n\n    // Commit if all operations succeed\n    COMMIT;\n} ON_CONFLICT {\n    // Handle conflicts\n    ROLLBACK;\n}\n</code></pre></p>"},{"location":"concepts/concurrency/#best-practices","title":"Best Practices","text":"<ol> <li>Minimize Shared State</li> <li>Prefer message passing</li> <li>Use value semantics</li> <li> <p>Isolate mutable state</p> </li> <li> <p>Use Higher-Level Abstractions</p> </li> <li>Prefer <code>PARALLEL_MAP</code> over manual threading</li> <li>Use channels for communication</li> <li> <p>Leverage the type system</p> </li> <li> <p>Handle Errors Gracefully</p> </li> <li>Timeout all blocking operations</li> <li>Implement backpressure</li> <li>Monitor resource usage</li> </ol>"},{"location":"concepts/concurrency/#performance-considerations","title":"Performance Considerations","text":""},{"location":"concepts/concurrency/#1-task-granularity","title":"1. Task Granularity","text":"<ul> <li>Balance between overhead and parallelism</li> <li>Consider cache effects</li> <li>Profile and measure</li> </ul>"},{"location":"concepts/concurrency/#2-memory-locality","title":"2. Memory Locality","text":"<ul> <li>Keep data close to computation</li> <li>Minimize cross-thread communication</li> <li>Consider NUMA effects</li> </ul>"},{"location":"concepts/concurrency/#3-load-balancing","title":"3. Load Balancing","text":"<ul> <li>Dynamic work distribution</li> <li>Work stealing</li> <li>Adaptive scheduling</li> </ul>"},{"location":"concepts/concurrency/#advanced-topics","title":"Advanced Topics","text":""},{"location":"concepts/concurrency/#1-lock-free-data-structures","title":"1. Lock-Free Data Structures","text":"<ul> <li>Atomic operations</li> <li>Memory ordering</li> <li>Hazard pointers</li> </ul>"},{"location":"concepts/concurrency/#2-software-transactional-memory","title":"2. Software Transactional Memory","text":"<ul> <li>Atomic blocks</li> <li>Optimistic concurrency</li> <li>Conflict detection</li> </ul>"},{"location":"concepts/concurrency/#3-distributed-computing","title":"3. Distributed Computing","text":"<ul> <li>Message passing</li> <li>Consistency models</li> <li>Failure handling</li> </ul>"},{"location":"concepts/concurrency/#next-steps","title":"Next Steps","text":"<ul> <li>Temporal Programming</li> <li>Resource Management</li> <li>Performance Considerations</li> </ul>"},{"location":"concepts/resource_management/","title":"Resource Management in Chronovyan","text":""},{"location":"concepts/resource_management/#overview","title":"Overview","text":"<p>Chronovyan's resource management system is designed to handle the unique challenges of temporal programming, ensuring that temporal operations are performed safely and efficiently while preventing paradoxes and maintaining timeline consistency.</p>"},{"location":"concepts/resource_management/#core-resources","title":"Core Resources","text":""},{"location":"concepts/resource_management/#1-chronon","title":"1. Chronon","text":"<p>Definition: The fundamental quantum of time in Chronovyan.</p> <p>Characteristics: - Immutable and discrete - Used for ordering events - Represents points in the timeline</p> <p>Example: <pre><code>// Get the current chronon\nLET current = NOW();\n\n// Create a specific point in time\nLET future_time = current + 1h + 30m;\n</code></pre></p>"},{"location":"concepts/resource_management/#2-aethel","title":"2. Aethel","text":"<p>Definition: The energy resource that powers temporal operations.</p> <p>Characteristics: - Consumed by temporal operations - Regenerated over time - Must be managed to prevent exhaustion</p> <p>Example: <pre><code>// Check available Aethel\nLET available = GET_AVAILABLE_AETHEL();\n\n// Allocate Aethel for an operation\nALLOCATE_AETHEL(50);\n\n// Perform Aethel-consuming operation\nTIMELINE_BRANCH(\"alternate_reality\");\n</code></pre></p>"},{"location":"concepts/resource_management/#resource-allocation-strategies","title":"Resource Allocation Strategies","text":""},{"location":"concepts/resource_management/#1-static-allocation","title":"1. Static Allocation","text":"<ul> <li>Fixed at compile-time</li> <li>Known resource requirements</li> <li>Most efficient but least flexible</li> </ul> <p>Example: <pre><code>// Statically allocated buffer\nDECLARE CONF::STATIC BUFFER_SIZE = 1024;\nDECLARE CONF::STATIC buffer[BUFFER_SIZE];\n</code></pre></p>"},{"location":"concepts/resource_management/#2-dynamic-allocation","title":"2. Dynamic Allocation","text":"<ul> <li>Allocated at runtime</li> <li>Flexible but requires management</li> <li>Can lead to fragmentation</li> </ul> <p>Example: <pre><code>// Dynamically allocate memory\nLET size = calculate_required_size();\nLET buffer = ALLOCATE(size);\n\n// Don't forget to free!\nDEALLOCATE(buffer);\n</code></pre></p>"},{"location":"concepts/resource_management/#3-pooled-allocation","title":"3. Pooled Allocation","text":"<ul> <li>Pre-allocated pools of resources</li> <li>Good for fixed-size objects</li> <li>Reduces allocation overhead</li> </ul> <p>Example: <pre><code>// Create a pool of 100 events\nLET event_pool = CREATE_POOL(EVENT, 100);\n\n// Get an event from the pool\nLET evt = POOL_ALLOCATE(event_pool);\n\n// Return to pool when done\nPOOL_FREE(event_pool, evt);\n</code></pre></p>"},{"location":"concepts/resource_management/#memory-management","title":"Memory Management","text":""},{"location":"concepts/resource_management/#1-ownership-semantics","title":"1. Ownership Semantics","text":"<ul> <li>Clear ownership of resources</li> <li>Prevents double-free and use-after-free</li> <li>Enforced by the type system</li> </ul> <p>Example: <pre><code>// Transfer ownership with MOVE\nLET resource = ACQUIRE_RESOURCE();\nPROCESS_RESOURCE(MOVE(resource));  // Ownership transferred\n// resource is no longer valid here\n</code></pre></p>"},{"location":"concepts/resource_management/#2-reference-counting","title":"2. Reference Counting","text":"<ul> <li>Automatic memory management</li> <li>Thread-safe reference counting</li> <li>No garbage collection pauses</li> </ul> <p>Example: <pre><code>// Create a reference-counted object\nLET rc = MAKE_REFCOUNTED&lt;MyObject&gt;(arg1, arg2);\n\n// References are automatically managed\nLET another_ref = rc;  // Reference count increases\n</code></pre></p>"},{"location":"concepts/resource_management/#best-practices","title":"Best Practices","text":"<ol> <li>RAII (Resource Acquisition Is Initialization)</li> <li>Acquire resources in constructors</li> <li>Release in destructors</li> <li> <p>Use smart pointers</p> </li> <li> <p>Temporal Locality</p> </li> <li>Keep related data close in time</li> <li>Minimize temporal jumps</li> <li> <p>Batch operations when possible</p> </li> <li> <p>Resource Monitoring</p> </li> <li>Track resource usage</li> <li>Set limits and quotas</li> <li>Handle exhaustion gracefully</li> </ol>"},{"location":"concepts/resource_management/#advanced-topics","title":"Advanced Topics","text":""},{"location":"concepts/resource_management/#1-custom-allocators","title":"1. Custom Allocators","text":"<ul> <li>Implement custom memory management</li> <li>Optimize for specific access patterns</li> <li>Support specialized hardware</li> </ul>"},{"location":"concepts/resource_management/#2-resource-pools","title":"2. Resource Pools","text":"<ul> <li>Manage groups of related resources</li> <li>Implement object pooling</li> <li>Reduce allocation overhead</li> </ul>"},{"location":"concepts/resource_management/#3-garbage-collection","title":"3. Garbage Collection","text":"<ul> <li>Reference counting</li> <li>Cycle detection</li> <li>Generational collection</li> </ul>"},{"location":"concepts/resource_management/#next-steps","title":"Next Steps","text":"<ul> <li>Temporal Programming</li> <li>Concurrency Model</li> <li>Performance Considerations</li> </ul>"},{"location":"concepts/temporal_programming/","title":"Temporal Programming in Chronovyan","text":""},{"location":"concepts/temporal_programming/#the-great-duality","title":"The Great Duality","text":"<p>Chronovyan is built around two fundamental principles that govern all temporal operations:</p>"},{"location":"concepts/temporal_programming/#1-order-conformity","title":"1. Order (Conformity)","text":"<p>Stability and Predictability - Enforces deterministic behavior - Ensures consistent execution across runs - Provides a stable foundation for temporal operations</p> <p>Key Concepts: - <code>CONF</code> variables (Conformity) - <code>::STATIC</code> flag for immutable values - Deterministic control flow - Predictable resource consumption</p> <p>Example: <pre><code>// A static, unchanging value\nDECLARE CONF::STATIC MAX_ITERATIONS : INT = 1000;\n\n// A function with deterministic behavior\nFUNC INT calculate_fibonacci(INT n) {\n    IF (n &lt;= 1) {\n        RETURN n;\n    }\n    RETURN calculate_fibonacci(n-1) + calculate_fibonacci(n-2);\n}\n</code></pre></p>"},{"location":"concepts/temporal_programming/#2-flux-rebellion","title":"2. Flux (Rebellion)","text":"<p>Dynamic Adaptation - Enables temporal manipulation - Allows for adaptive behavior - Supports runtime modifications</p> <p>Key Concepts: - <code>REB</code> variables (Rebellion) - <code>::FLUX</code> flag for mutable state - Dynamic resource allocation - Temporal manipulation operations</p> <p>Example: <pre><code>// A mutable value that can change over time\nDECLARE REB::FLUX current_time : TIMESTAMP = NOW();\n\n// Function that can modify temporal state\nFUNC VOID adjust_timeline(FLOAT factor) {\n    // Modify the flow of time\n    SET_TIME_DILATION(factor);\n}\n</code></pre></p>"},{"location":"concepts/temporal_programming/#temporal-resources","title":"Temporal Resources","text":"<p>Chronovyan manages two primary temporal resources:</p>"},{"location":"concepts/temporal_programming/#1-chronon","title":"1. Chronon","text":"<ul> <li>Basic quantum of time</li> <li>Represents discrete moments in the timeline</li> <li>Used for scheduling and ordering events</li> </ul>"},{"location":"concepts/temporal_programming/#2-aethel","title":"2. Aethel","text":"<ul> <li>Temporal energy resource</li> <li>Consumed by temporal operations</li> <li>Must be managed carefully to prevent paradoxes</li> </ul> <p>Example: <pre><code>// Allocate Aethel for temporal operations\nALLOCATE_AETHEL(100);\n\n// Perform a temporal operation that consumes Aethel\nTIMELINE_SPLIT(\"branch_1\", 0.5);  // Consumes Aethel\n</code></pre></p>"},{"location":"concepts/temporal_programming/#temporal-safety","title":"Temporal Safety","text":"<p>Chronovyan enforces temporal safety through:</p> <ol> <li>Type System</li> <li>Temporal types with compile-time checking</li> <li>Resource tracking</li> <li> <p>Side effect analysis</p> </li> <li> <p>Runtime Checks</p> </li> <li>Paradox detection</li> <li>Resource exhaustion</li> <li> <p>Timeline consistency</p> </li> <li> <p>Deterministic Execution</p> </li> <li>Predictable behavior</li> <li>Reproducible results</li> <li>Controlled non-determinism when explicitly requested</li> </ol>"},{"location":"concepts/temporal_programming/#next-steps","title":"Next Steps","text":"<ul> <li>Resource Management</li> <li>Concurrency Model</li> <li>Language Reference</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>This section contains practical examples of using Chronovyan for various tasks.</p>"},{"location":"examples/#basic-examples","title":"Basic Examples","text":"<ul> <li>Hello World - A simple introduction to Chronovyan</li> <li>Temporal Examples - Creating custom event types and managing time</li> </ul>"},{"location":"examples/#intermediate-examples","title":"Intermediate Examples","text":"<ul> <li>Temporal Examples - Advanced temporal programming concepts</li> <li>Hello World - A simple introduction to Chronovyan</li> </ul>"},{"location":"examples/#advanced-examples","title":"Advanced Examples","text":"<p>Coming soon! We're working on adding more advanced examples, including:</p> <ul> <li>Creating animations</li> <li>Building simulations</li> <li>Game development</li> </ul> <p>Check back soon or contribute your own examples on GitHub!</p>"},{"location":"examples/#getting-started-with-examples","title":"Getting Started with Examples","text":"<p>To run these examples, first make sure you have Chronovyan installed:</p> <pre><code>pip install chronovyan\n</code></pre> <p>Then, you can copy and paste the example code into a Python file and run it:</p> <pre><code>python example.py\n</code></pre>"},{"location":"examples/#contributing-examples","title":"Contributing Examples","text":"<p>We welcome contributions of new examples! If you've created an example that you'd like to share, please open a pull request on GitHub.</p>"},{"location":"examples/hello_world/","title":"Hello World Example","text":"<p>This is a simple \"Hello World\" example to get you started with Chronovyan.</p>"},{"location":"examples/hello_world/#the-code","title":"The Code","text":"<pre><code>import chronovyan as cv\n\ndef say_hello(event):\n    print(f\"{event.name} at {event.timestamp:.2f} seconds\")\n\ndef main():\n    print(\"Starting Chronovyan Hello World example...\")\n\n    # Create a new timeline\n    timeline = cv.Timeline()\n\n    # Add some events\n    timeline.add_event(cv.Event(\"Hello\", on_trigger=say_hello))\n    timeline.add_event(cv.Event(\"World\", delay=1.0, on_trigger=say_hello))\n\n    # Run the timeline\n    print(\"Running timeline...\")\n    timeline.run()\n    print(\"Timeline complete!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/hello_world/#explanation","title":"Explanation","text":"<ol> <li> <p>Import the library: We start by importing the Chronovyan library.</p> </li> <li> <p>Create a callback function: The <code>say_hello</code> function will be called when each event is triggered.</p> </li> <li> <p>Create a timeline: The <code>Timeline</code> object will manage our events.</p> </li> <li> <p>Add events: We add two events to the timeline:</p> </li> <li>The first event says \"Hello\" immediately</li> <li> <p>The second event says \"World\" after a 1-second delay</p> </li> <li> <p>Run the timeline: The <code>run()</code> method starts the timeline and processes all events.</p> </li> </ol>"},{"location":"examples/hello_world/#expected-output","title":"Expected Output","text":"<p>When you run this code, you should see output similar to:</p> <pre><code>Starting Chronovyan Hello World example...\nRunning timeline...\nHello at 0.00 seconds\nWorld at 1.00 seconds\nTimeline complete!\n</code></pre>"},{"location":"examples/hello_world/#next-steps","title":"Next Steps","text":"<ul> <li>Try modifying the delays between events</li> <li>Add more events to the timeline</li> <li>Experiment with different callback functions</li> <li>For more examples, see the Temporal Examples page.</li> </ul>"},{"location":"examples/temporal_examples/","title":"Temporal Programming Examples","text":"<p>This page contains practical examples demonstrating Chronovyan's temporal programming capabilities. These examples range from basic to advanced, showcasing the language's unique features for handling time and state.</p>"},{"location":"examples/temporal_examples/#basic-examples","title":"Basic Examples","text":""},{"location":"examples/temporal_examples/#1-hello-world-with-temporal-context","title":"1. Hello World with Temporal Context","text":"<pre><code>// A simple program demonstrating basic temporal structure\ntemporal_program {\n    name: \"Hello World\";\n    type: standard;\n\n    resources: {\n        aethel: 5;\n        chronon: 3;\n    }\n\n    variables: {\n        greeting: {\n            type: CONF;\n            flags: [::STATIC];\n            value: \"Hello, Temporal World!\";\n        }\n    }\n\n    execution: {\n        FOR_CHRONON {\n            iterations: 1;\n            body: {\n                output: greeting;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"examples/temporal_examples/#2-counter-with-stability","title":"2. Counter with Stability","text":"<pre><code>// Demonstrates variable stability and basic counting\ntemporal_program {\n    name: \"Stable Counter\";\n    type: standard;\n\n    resources: {\n        aethel: 8;\n        chronon: 4;\n    }\n\n    variables: {\n        counter: {\n            type: CONF;\n            flags: [::STATIC];\n            value: 0;\n        },\n\n        status: {\n            type: REB;\n            flags: [::VOLATILE];\n            value: \"active\";\n        }\n    }\n\n    execution: {\n        FOR_CHRONON {\n            iterations: 3;\n            body: {\n                increment: counter;\n                monitor: status;\n                output: {\n                    counter: counter;\n                    status: status;\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"examples/temporal_examples/#intermediate-examples","title":"Intermediate Examples","text":""},{"location":"examples/temporal_examples/#3-resource-monitoring","title":"3. Resource Monitoring","text":"<pre><code>// Demonstrates resource monitoring and management\ntemporal_program {\n    name: \"Resource Monitor\";\n    type: standard;\n\n    resources: {\n        aethel: 15;\n        chronon: 10;\n    }\n\n    variables: {\n        resource_levels: {\n            type: MAP&lt;STRING, INT&gt;;\n            flags: [::MONITORED];\n            value: {\n                \"aethel\": 100,\n                \"chronon\": 50\n            };\n        },\n\n        alert_threshold: {\n            type: INT;\n            flags: [::STATIC];\n            value: 20;\n        }\n    }\n\n    execution: {\n        FOR_CHRONON {\n            iterations: 5;\n            body: {\n                // Simulate resource consumption\n                DECREMENT(resource_levels[\"aethel\"], 5);\n                DECREMENT(resource_levels[\"chronon\"], 3);\n\n                // Check thresholds\n                IF (resource_levels[\"aethel\"] &lt; alert_threshold) {\n                    output: \"WARNING: Low Aethel levels!\";\n                }\n\n                output: resource_levels;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"examples/temporal_examples/#advanced-examples","title":"Advanced Examples","text":""},{"location":"examples/temporal_examples/#4-temporal-branching","title":"4. Temporal Branching","text":"<pre><code>// Demonstrates creating and managing temporal branches\ntemporal_program {\n    name: \"Temporal Branch Explorer\";\n    type: advanced;\n\n    resources: {\n        aethel: 30;\n        chronon: 20;\n    }\n\n    variables: {\n        branch_count: {\n            type: INT;\n            flags: [::STATIC];\n            value: 0;\n        },\n\n        current_reality: {\n            type: STRING;\n            flags: [::VOLATILE];\n            value: \"prime\";\n        }\n    }\n\n    execution: {\n        // Create initial branch\n        TEMPORAL_BRANCH(\"alternate_reality\") {\n            branch_count++;\n            current_reality = \"alternate_reality\";\n            output: \"Created branch: \" + branch_count;\n\n            // Nested branch\n            TEMPORAL_BRANCH(\"nested_reality\") {\n                branch_count++;\n                current_reality = \"nested_reality\";\n                output: \"Created nested branch: \" + branch_count;\n            }\n        }\n\n        // Return to prime timeline\n        current_reality = \"prime\";\n        output: \"Current reality: \" + current_reality;\n        output: \"Total branches created: \" + branch_count;\n    }\n}\n</code></pre>"},{"location":"examples/temporal_examples/#5-quantum-entanglement","title":"5. Quantum Entanglement","text":"<pre><code>// Demonstrates quantum entanglement between temporal variablestemporal_program {\n    name: \"Quantum Entanglement Demo\";\n    type: quantum;\n\n    resources: {\n        aethel: 50;\n        chronon: 30;\n    }\n\n    variables: {\n        particle_a: {\n            type: INT;\n            flags: [::QUANTUM];\n            value: 0;\n        },\n\n        particle_b: {\n            type: INT;\n            flags: [::QUANTUM];\n            value: 0;\n        },\n\n        entangled: BOOL = false;\n    }\n\n    execution: {\n        // Entangle the particles\n        QUANTUM_ENTANGLE(particle_a, particle_b);\n        entangled = true;\n\n        // Modify one particle\n        particle_a = 1;\n\n        // The other particle should reflect the change\n        output: \"Particle A: \" + particle_a;\n        output: \"Particle B: \" + particle_b;  // Will also be 1\n\n        // Break the entanglement\n        QUANTUM_DISENTANGLE(particle_a, particle_b);\n        entangled = false;\n    }\n}\n</code></pre>"},{"location":"examples/temporal_examples/#best-practices","title":"Best Practices","text":"<ol> <li>Resource Management</li> <li>Always monitor Aethel and Chronon levels</li> <li>Set appropriate resource limits for your programs</li> <li> <p>Handle resource exhaustion gracefully</p> </li> <li> <p>Temporal Safety</p> </li> <li>Use appropriate variable flags (CONF/REB, STATIC/FLUX)</li> <li>Be cautious with temporal branching</li> <li> <p>Validate temporal conditions before operations</p> </li> <li> <p>Performance</p> </li> <li>Minimize temporal jumps</li> <li>Use appropriate loop constructs</li> <li>Consider the cost of quantum operations</li> </ol>"},{"location":"examples/temporal_examples/#next-steps","title":"Next Steps","text":"<ul> <li>Language Reference</li> <li>API Reference</li> <li>Performance Tips</li> </ul>"},{"location":"getting-started/first-steps/","title":"First Steps with Chronovyan","text":"<p>Welcome to Chronovyan! This guide will help you take your first steps with the language.</p>"},{"location":"getting-started/first-steps/#your-first-chronovyan-program","title":"Your First Chronovyan Program","text":"<p>Let's create a simple Chronovyan program to get started:</p> <pre><code>import chronovyan as cv\n\n# Create a new timeline\ntimeline = cv.Timeline()\n\n# Add an event to the timeline\ntimeline.add_event(\"Hello, Chronovyan!\")\n\n# Run the timeline\ntimeline.run()\n</code></pre>"},{"location":"getting-started/first-steps/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/first-steps/#1-timelines","title":"1. Timelines","text":"<p>A <code>Timeline</code> is a sequence of events that occur over time. You can add events to a timeline and then execute them in order.</p> <pre><code>timeline = cv.Timeline()\n\n# Add events with delays\ntimeline.add_event(\"First event\", delay=1.0)  # 1 second delay\ntimeline.add_event(\"Second event\")           # No delay\n\n# Run the timeline\ntimeline.run()\n</code></pre>"},{"location":"getting-started/first-steps/#2-events","title":"2. Events","text":"<p>Events are the building blocks of Chronovyan programs. They can be simple strings or more complex objects.</p> <pre><code># Simple event\nevent1 = cv.Event(\"A simple event\")\n\n# Event with data\nevent2 = cv.Event(\"Event with data\", data={\"key\": \"value\"})\n\n# Add events to timeline\ntimeline.add_event(event1)\ntimeline.add_event(event2)\n</code></pre>"},{"location":"getting-started/first-steps/#3-callbacks","title":"3. Callbacks","text":"<p>You can attach callbacks to events to perform actions when they occur.</p> <pre><code>def on_event(event):\n    print(f\"Event occurred: {event.name}\")\n    print(f\"Event data: {event.data}\")\n\n# Create an event with a callback\nevent = cv.Event(\"Event with callback\", on_trigger=on_event)\ntimeline.add_event(event)\n</code></pre>"},{"location":"getting-started/first-steps/#next-steps","title":"Next Steps","text":"<p>Now that you've taken your first steps with Chronovyan, you can explore:</p> <ul> <li>Examples - Check out our examples section for more advanced features and techniques</li> <li>API Reference - Detailed documentation of all classes and methods</li> <li>Core Concepts - Deep dive into Chronovyan's architecture</li> </ul>"},{"location":"getting-started/first-steps/#need-help","title":"Need Help?","text":"<p>If you have any questions or run into issues, feel free to open an issue on GitHub.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide will help you install Chronovyan on your system.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>pip (Python package manager)</li> <li>Git (for development)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#from-source-recommended","title":"From Source (Recommended)","text":"<p>Since Chronovyan is in active development, the recommended way to install it is from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/Chronovyan/Chronovyan.github.io.git\ncd Chronovyan\n\n# Install in development mode\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#verifying-the-installation","title":"Verifying the Installation","text":"<p>After installation, you can verify that Chronovyan is installed correctly by running:</p> <pre><code>python -c \"from chronovyan import Timeline; print('Chronovyan imported successfully')\"\n</code></pre>"},{"location":"getting-started/installation/#updating-chronovyan","title":"Updating Chronovyan","text":"<p>To update to the latest version, pull the latest changes and reinstall:</p> <pre><code>git pull origin main\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Permission Errors: If you encounter permission errors, try installing with the <code>--user</code> flag:    <pre><code>pip install --user chronovyan\n</code></pre></p> </li> <li> <p>Python Version: Ensure you're using Python 3.8 or higher. Check your Python version with:    <pre><code>python --version\n</code></pre></p> </li> <li> <p>Dependencies: If you encounter dependency issues, try:    <pre><code>pip install --upgrade pip setuptools wheel\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have Chronovyan installed, check out the First Steps guide to start using it!</p>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get up and running with Chronovyan as quickly as possible.</p>"},{"location":"getting-started/quickstart/#installation","title":"Installation","text":"<pre><code>pip install chronovyan\n</code></pre>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#1-import-chronovyan","title":"1. Import Chronovyan","text":"<pre><code>import chronovyan as cv\n</code></pre>"},{"location":"getting-started/quickstart/#2-create-a-timeline","title":"2. Create a Timeline","text":"<pre><code>timeline = cv.Timeline()\n</code></pre>"},{"location":"getting-started/quickstart/#3-add-events","title":"3. Add Events","text":"<pre><code># Add a simple event\ntimeline.add_event(\"Hello, World!\")\n\n# Add an event with a delay\ntimeline.add_event(\"This happens after 1 second\", delay=1.0)\n</code></pre>"},{"location":"getting-started/quickstart/#4-run-the-timeline","title":"4. Run the Timeline","text":"<pre><code>timeline.run()\n</code></pre>"},{"location":"getting-started/quickstart/#example-simple-animation","title":"Example: Simple Animation","text":"<p>Here's a simple example that creates a timeline with multiple events:</p> <pre><code>import chronovyan as cv\n\ndef print_message(event):\n    print(f\"At {event.timestamp:.2f}s: {event.name}\")\n\n# Create a new timeline\ntimeline = cv.Timeline()\n\n# Add some events\ntimeline.add_event(cv.Event(\"Start\", on_trigger=print_message))\ntimeline.add_event(cv.Event(\"Processing...\", delay=0.5, on_trigger=print_message))\ntimeline.add_event(cv.Event(\"Almost done\", delay=1.0, on_trigger=print_message))\ntimeline.add_event(cv.Event(\"Complete!\", delay=1.5, on_trigger=print_message))\n\n# Run the timeline\nprint(\"Starting timeline...\")\ntimeline.run()\nprint(\"Timeline complete!\")\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more in the First Steps guide</li> <li>Explore the API Reference</li> <li>Check out the examples for more complex use cases</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>This section provides detailed documentation for the Chronovyan API.</p>"},{"location":"reference/#core-classes","title":"Core Classes","text":""},{"location":"reference/#timeline","title":"Timeline","text":"<p>The main class for managing a sequence of events.</p>"},{"location":"reference/#methods","title":"Methods","text":"<ul> <li><code>add_event(event, delay=0.0)</code>: Add an event to the timeline</li> <li><code>run()</code>: Execute all events in the timeline</li> <li><code>pause()</code>: Pause the timeline</li> <li><code>resume()</code>: Resume a paused timeline</li> <li><code>stop()</code>: Stop the timeline execution</li> </ul>"},{"location":"reference/#properties","title":"Properties","text":"<ul> <li><code>is_running</code>: Whether the timeline is currently running</li> <li><code>current_time</code>: The current time in the timeline</li> <li><code>event_count</code>: Number of events in the timeline</li> </ul>"},{"location":"reference/#event","title":"Event","text":"<p>Represents an event in the timeline.</p>"},{"location":"reference/#constructor","title":"Constructor","text":"<pre><code>Event(name, data=None, on_trigger=None, delay=0.0)\n</code></pre>"},{"location":"reference/#properties_1","title":"Properties","text":"<ul> <li><code>name</code>: The name of the event</li> <li><code>data</code>: Optional data associated with the event</li> <li><code>timestamp</code>: When the event is scheduled to occur</li> <li><code>is_triggered</code>: Whether the event has been triggered</li> </ul>"},{"location":"reference/#utility-functions","title":"Utility Functions","text":""},{"location":"reference/#time-utilities","title":"Time Utilities","text":"<ul> <li><code>get_current_time()</code>: Get the current time in the timeline</li> <li><code>sleep(seconds)</code>: Sleep for the specified number of seconds</li> </ul>"},{"location":"reference/#examples","title":"Examples","text":""},{"location":"reference/#creating-and-running-a-timeline","title":"Creating and Running a Timeline","text":"<pre><code>import chronovyan as cv\n\ndef on_event(event):\n    print(f\"Event: {event.name}\")\n\n# Create a timeline\ntimeline = cv.Timeline()\n\n# Add some events\ntimeline.add_event(cv.Event(\"Start\", on_trigger=on_event))\ntimeline.add_event(cv.Event(\"Middle\", on_trigger=on_event, delay=1.0))\ntimeline.add_event(cv.Event(\"End\", on_trigger=on_event, delay=2.0))\n\n# Run the timeline\ntimeline.run()\n</code></pre>"},{"location":"reference/#advanced-topics","title":"Advanced Topics","text":""},{"location":"reference/#custom-events","title":"Custom Events","text":"<p>You can create custom event types by subclassing <code>Event</code>:</p> <pre><code>class CustomEvent(cv.Event):\n    def __init__(self, name, custom_data, **kwargs):\n        super().__init__(name, **kwargs)\n        self.custom_data = custom_data\n\n    def trigger(self):\n        print(f\"Custom event triggered with data: {self.custom_data}\")\n        super().trigger()\n\n# Usage\nevent = CustomEvent(\"Custom\", custom_data=42, delay=1.0)\ntimeline.add_event(event)\n</code></pre>"},{"location":"reference/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Set up Chronovyan</li> <li>Core Concepts - Learn about Chronovyan's architecture</li> <li>Examples - Practical examples of Chronovyan in action</li> </ul>"},{"location":"reference/api_reference/","title":"Chronovyan API Reference","text":""},{"location":"reference/api_reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li>1. Resource Management</li> <li>1.1 ResourceTracker</li> <li>1.2 ResourceProcessor</li> <li>1.3 Resource Types</li> <li>2. Temporal Operations</li> <li>2.1 Timeline Management</li> <li>2.2 Temporal Variables</li> <li>2.3 Quantum Operations</li> <li>3. Standard Library</li> <li>3.1 Core Types</li> <li>3.2 Built-in Functions</li> </ul>"},{"location":"reference/api_reference/#1-resource-management","title":"1. Resource Management","text":""},{"location":"reference/api_reference/#11-resourcetracker","title":"1.1 ResourceTracker","text":"<p>Tracks and manages temporal resources (Aethel and Chronon).</p> <pre><code>// Create a new resource tracker\nLET tracker = NEW ResourceTracker(\n    initial_aethel: 100,\n    initial_chronon: 50\n);\n\n// Check current resource levels\nLET aethel = tracker.get_aethel();\nLET chronon = tracker.get_chronon();\n\n// Consume resources\nTRACKED_OPERATION(tracker, 10, 5) {\n    // Operation that consumes 10 Aethel and 5 Chronon\n}\n</code></pre>"},{"location":"reference/api_reference/#12-resourceprocessor","title":"1.2 ResourceProcessor","text":"<p>Processes and optimizes resource allocations.</p> <pre><code>// Create a processor with a tracker\nLET processor = NEW ResourceProcessor(tracker);\n\n// Optimize resource allocation\nprocessor.optimize_allocation(\n    required_aethel: 50,\n    required_chronon: 25\n);\n\n// Process a temporal operation\nprocessor.process_operation(\n    operation_type: \"TIMELINE_SPLIT\",\n    parameters: {\"branches\": 2}\n);\n</code></pre>"},{"location":"reference/api_reference/#13-resource-types","title":"1.3 Resource Types","text":"Type Description Default Value Aethel Temporal energy resource 0 Chronon Basic quantum of time 0 Timeline Sequence of temporal events null QuantumState Quantum state representation null"},{"location":"reference/api_reference/#2-temporal-operations","title":"2. Temporal Operations","text":""},{"location":"reference/api_reference/#21-timeline-management","title":"2.1 Timeline Management","text":"<pre><code>// Create a new timeline\nLET timeline = NEW Timeline(\"main_timeline\");\n\n// Add an event\nTIMELINE_ADD_EVENT(\n    timeline: timeline,\n    timestamp: NOW() + 1h,\n    callback: \\() { PRINT(\"Event triggered\"); }\n);\n\n// Branch the timeline\nLET branch = TIMELINE_BRANCH(\"alternate_reality\");\n\n// Merge timelines\nTIMELINE_MERGE(source: branch, target: timeline);\n</code></pre>"},{"location":"reference/api_reference/#22-temporal-variables","title":"2.2 Temporal Variables","text":"<pre><code>// CONF (Conformity) variable\nDECLARE CONF::STATIC MAX_ITERATIONS: INT = 100;\n\n// REB (Rebellion) variable\nDECLARE REB::FLUX current_state: STRING = \"initial\";\n\n// Temporal variable with quantum properties\nDECLARE QUANTUM::ENTANGLED particle_spin: INT = 0;\n</code></pre>"},{"location":"reference/api_reference/#23-quantum-operations","title":"2.3 Quantum Operations","text":"<pre><code>// Create quantum entanglement\nQUANTUM_ENTANGLE(particle_a, particle_b);\n\n// Superposition\nLET qbit = QUANTUM_SUPERPOSITION(0, 1);\n\n// Quantum measurement\nLET result = MEASURE(qbit);\n</code></pre>"},{"location":"reference/api_reference/#3-standard-library","title":"3. Standard Library","text":""},{"location":"reference/api_reference/#31-core-types","title":"3.1 Core Types","text":"Type Description INT 64-bit signed integer FLOAT 64-bit floating point BOOL Boolean value STRING UTF-8 encoded string ARRAY Dynamic array of type T MAP Hash map with keys K and values V OPTIONAL May contain a value of type T or be empty RESULT Represents success (T) or failure (E)"},{"location":"reference/api_reference/#32-built-in-functions","title":"3.2 Built-in Functions","text":""},{"location":"reference/api_reference/#temporal-functions","title":"Temporal Functions","text":"<pre><code>// Get current timestamp\nLET now = NOW();\n\n// Create a duration\nLET duration = DURATION(hours: 1, minutes: 30);\n\n// Sleep for a duration\nSLEEP(duration);\n\n// Create a timer\nLET timer = TIMER(START);\n// ...\nLET elapsed = TIMER(STOP, timer);\n</code></pre>"},{"location":"reference/api_reference/#mathematical-functions","title":"Mathematical Functions","text":"<pre><code>// Basic math\nLET sum = ADD(5, 3);\nLET product = MULTIPLY(4, 7);\n\n// Advanced math\nLET root = SQRT(16);\nLET power = POW(2, 10);\n\n// Random numbers\nLET rand = RANDOM(1, 100);\n</code></pre>"},{"location":"reference/api_reference/#io-functions","title":"I/O Functions","text":"<pre><code>// Print to console\nPRINT(\"Hello, Chronovyan!\");\n\n// Read input\nLET name = INPUT(\"Enter your name: \");\n\n// File operations\nLET file = FILE_OPEN(\"data.txt\", \"r\");\nLET content = FILE_READ(file);\nFILE_CLOSE(file);\n</code></pre>"},{"location":"reference/api_reference/#best-practices","title":"Best Practices","text":"<ol> <li>Resource Management</li> <li>Always check resource availability before operations</li> <li>Use TRACKED_OPERATION for automatic resource tracking</li> <li> <p>Implement cleanup in FINALLY blocks</p> </li> <li> <p>Error Handling</p> </li> <li>Use RESULT type for fallible operations</li> <li>Handle temporal paradoxes explicitly</li> <li> <p>Provide meaningful error messages</p> </li> <li> <p>Performance</p> </li> <li>Minimize temporal jumps</li> <li>Use appropriate data structures</li> <li>Profile resource-intensive operations</li> </ol>"},{"location":"reference/api_reference/#version-information","title":"Version Information","text":"<ul> <li>Current Version: 1.0.0</li> <li>Last Updated: 2023-10-21</li> <li>API Stability: Experimental</li> </ul>"},{"location":"reference/api_reference/#see-also","title":"See Also","text":"<ul> <li>Language Specification</li> <li>Examples</li> <li>Performance Considerations</li> </ul>"},{"location":"reference/language_specification/","title":"Chronovyan Language Specification","text":""},{"location":"reference/language_specification/#1-introduction","title":"1. Introduction","text":"<p>Chronovyan is a statically-typed, temporal programming language designed for building time-aware applications. It introduces first-class concepts of time, temporal resources, and timeline management.</p>"},{"location":"reference/language_specification/#11-design-philosophy","title":"1.1 Design Philosophy","text":"<ul> <li>Temporal First: Time is a first-class citizen</li> <li>Type Safety: Strong, static typing with type inference</li> <li>Determinism: Predictable execution model</li> <li>Performance: Efficient resource management</li> </ul>"},{"location":"reference/language_specification/#12-language-version","title":"1.2 Language Version","text":"<ul> <li>Version: 1.0.0</li> <li>Status: Stable</li> <li>Release Date: 2023-10-21</li> </ul>"},{"location":"reference/language_specification/#2-lexical-structure","title":"2. Lexical Structure","text":""},{"location":"reference/language_specification/#21-character-set","title":"2.1 Character Set","text":"<ul> <li>Encoding: UTF-8</li> <li>Case Sensitivity: Yes</li> <li>Whitespace: Spaces, tabs, newlines, and comments</li> </ul>"},{"location":"reference/language_specification/#22-comments","title":"2.2 Comments","text":"<pre><code>// Single-line comment\n\n/* Multi-line\n   comment */\n\n/// Documentation comment\n/// @param name Parameter description\n</code></pre>"},{"location":"reference/language_specification/#3-basic-syntax","title":"3. Basic Syntax","text":""},{"location":"reference/language_specification/#31-program-structure","title":"3.1 Program Structure","text":"<pre><code>// Module declaration\nMODULE example;\n\n// Import statements\nIMPORT std.io;\nIMPORT temporal.core;\n\n// Constant declarations\nCONF INT MAX_ITERATIONS = 100;\n\n// Type declarations\nTYPE Point {\n    x: FLOAT;\n    y: FLOAT;\n    z: FLOAT;\n}\n\n// Function definition\nFUNC INT add(INT a, INT b) {\n    RETURN a + b;\n}\n\n// Main function\nFUNC VOID main() {\n    // Program entry point\n    io::println(\"Hello, Chronovyan!\");\n}\n</code></pre>"},{"location":"reference/language_specification/#32-variables-and-mutability","title":"3.2 Variables and Mutability","text":"<pre><code>// CONF (Conformity) - immutable by default\nCONF INT immutable = 42;\n\n// REB (Rebellion) - mutable\nREB INT mutable = 0;\n\n// Type inference\nLET inferred = \"Type inferred as string\";\n\n// Constants\nCONST FLOAT PI = 3.14159;\n</code></pre>"},{"location":"reference/language_specification/#33-temporal-variables","title":"3.3 Temporal Variables","text":"<pre><code>// Static temporal variable\nDECLARE CONF::STATIC start_time = NOW();\n\n// Flux (mutable) temporal variable\nDECLARE REB::FLUX current_state = \"initial\";\n\n// Quantum variable\nDECLARE QUANTUM::ENTANGLED qbit = 0;\n</code></pre>"},{"location":"reference/language_specification/#4-types","title":"4. Types","text":""},{"location":"reference/language_specification/#41-primitive-types","title":"4.1 Primitive Types","text":"Type Description Default BOOL Boolean (true/false) false INT 64-bit signed integer 0 FLOAT 64-bit floating point 0.0 CHAR Unicode code point '\\0' STRING UTF-8 encoded string \"\" DURATION Time duration 0s MOMENT Point in time EPOCH VOID No value N/A"},{"location":"reference/language_specification/#42-composite-types","title":"4.2 Composite Types","text":""},{"location":"reference/language_specification/#421-arrays","title":"4.2.1 Arrays","text":"<pre><code>// Fixed-size array\nLET numbers: INT[5] = [1, 2, 3, 4, 5];\n\n// Dynamic array\nLET dynamic: ARRAY&lt;STRING&gt; = [\"one\", \"two\"];\ndynamic.push(\"three\");\n</code></pre>"},{"location":"reference/language_specification/#422-tuples","title":"4.2.2 Tuples","text":"<pre><code>LET pair: (INT, STRING) = (42, \"answer\");\nLET (num, str) = pair;  // Destructuring\n</code></pre>"},{"location":"reference/language_specification/#423-structs","title":"4.2.3 Structs","text":"<pre><code>TYPE Person {\n    name: STRING;\n    age: INT;\n\n    FUNC STRING greet() {\n        RETURN \"Hello, \" + name;\n    }\n}\n\nLET alice = Person { name: \"Alice\", age: 30 };\n</code></pre>"},{"location":"reference/language_specification/#43-temporal-types","title":"4.3 Temporal Types","text":"Type Description TIMELINE Sequence of temporal events TEMPORAL Value that changes over time QUANTUM Quantum state of type T AETHEL Temporal energy resource CHRONON Basic quantum of time"},{"location":"reference/language_specification/#5-control-flow","title":"5. Control Flow","text":""},{"location":"reference/language_specification/#51-conditionals","title":"5.1 Conditionals","text":"<pre><code>// If-else\nIF (x &gt; 0) {\n    // Positive\n} ELSE IF (x &lt; 0) {\n    // Negative\n} ELSE {\n    // Zero\n}\n\n// When expression (like switch)\nMATCH value {\n    1 =&gt; io::println(\"One\"),\n    2 | 3 | 5 | 7 =&gt; io::println(\"Prime\"),\n    _ =&gt; io::println(\"Other\"),\n}\n</code></pre>"},{"location":"reference/language_specification/#52-loops","title":"5.2 Loops","text":"<pre><code>// For loop\nFOR (LET i = 0; i &lt; 10; i++) {\n    io::println(i);\n}\n\n// For-each\nFOR (item IN collection) {\n    io::println(item);\n}\n\n// While loop\nWHILE (condition) {\n    // ...\n}\n\n// Loop with break/continue\nFOR (;;) {\n    IF (should_break) BREAK;\n    IF (should_skip) CONTINUE;\n    // ...\n}\n</code></pre>"},{"location":"reference/language_specification/#53-temporal-control","title":"5.3 Temporal Control","text":"<pre><code>// Delay execution\nDELAY 1s;\n\n\n// Create a branch in time\nLET branch = TIMELINE_BRANCH(\"alternate\");\n\n// Merge timelines\nTIMELINE_MERGE(branch);\n\n// Quantum conditional\nQUANTUM_IF (qbit) {\n    // This block exists in superposition\n} ELSE {\n    // As does this one\n}\n</code></pre>"},{"location":"reference/language_specification/#6-functions","title":"6. Functions","text":""},{"location":"reference/language_specification/#61-function-declaration","title":"6.1 Function Declaration","text":"<pre><code>// Basic function\nFUNC INT add(INT a, INT b) {\n    RETURN a + b;\n}\n\n// Default parameters\nFUNC STRING greet(STRING name = \"World\") {\n    RETURN \"Hello, \" + name;\n}\n\n// Variadic function\nFUNC INT sum(INT... numbers) {\n    LET total = 0;\n    FOR (n IN numbers) {\n        total += n;\n    }\n    RETURN total;\n}\n</code></pre>"},{"location":"reference/language_specification/#62-higher-order-functions","title":"6.2 Higher-Order Functions","text":"<pre><code>// Function as parameter\nFUNC INT apply(INT a, INT b, FUNC(INT,INT) op) {\n    RETURN op(a, b);\n}\n\n// Lambda expression\nLET add = \\\\(INT a, INT b) -&gt; INT { RETURN a + b; };\nLET result = apply(5, 3, add);\n</code></pre>"},{"location":"reference/language_specification/#7-error-handling","title":"7. Error Handling","text":""},{"location":"reference/language_specification/#71-result-type","title":"7.1 Result Type","text":"<pre><code>FUNC RESULT&lt;INT, STRING&gt; divide(INT a, INT b) {\n    IF (b == 0) {\n        RETURN ERR(\"Division by zero\");\n    }\n    RETURN OK(a / b);\n}\n\n// Usage\nMATCH divide(10, 2) {\n    OK(result) =&gt; io::println(\"Result: \" + result),\n    ERR(msg) =&gt; io::println(\"Error: \" + msg),\n}\n</code></pre>"},{"location":"reference/language_specification/#72-panics","title":"7.2 Panics","text":"<pre><code>FUNC INT divide(INT a, INT b) {\n    IF (b == 0) {\n        PANIC(\"Division by zero\");\n    }\n    RETURN a / b;\n}\n\n// Recover from panic\nTRY {\n    LET result = divide(10, 0);\n} CATCH (e) {\n    io::println(\"Caught: \" + e.message());\n}\n</code></pre>"},{"location":"reference/language_specification/#8-concurrency","title":"8. Concurrency","text":""},{"location":"reference/language_specification/#81-threads","title":"8.1 Threads","text":"<pre><code>// Spawn a new thread\nLET handle = SPAWN {\n    // This runs in parallel\n    io::println(\"Hello from another thread\");\n};\n\n// Wait for thread to complete\nAWAIT handle;\n</code></pre>"},{"location":"reference/language_specification/#82-channels","title":"8.2 Channels","text":"<pre><code>// Create a channel\nLET (tx, rx) = CHANNEL&lt;INT&gt;();\n\n// Send data in one thread\nSPAWN {\n    tx.send(42);\n};\n\n// Receive in another\nLET value = rx.recv();\n</code></pre>"},{"location":"reference/language_specification/#9-memory-management","title":"9. Memory Management","text":""},{"location":"reference/language_specification/#91-ownership","title":"9.1 Ownership","text":"<pre><code>// Transfer ownership\nLET s1 = \"Hello\".to_string();\nLET s2 = s1;  // s1 is moved, not copied\n// s1 is no longer valid here\n\n// Borrowing\nFUNC INT string_length(STRING &amp;s) {\n    RETURN s.length();\n}\n\n// Mutable borrow\nFUNC VOID append_world(STRING &amp;mut s) {\n    s += \" World\";\n}\n</code></pre>"},{"location":"reference/language_specification/#92-lifetimes","title":"9.2 Lifetimes","text":"<pre><code>// Explicit lifetime parameter\nFUNC &amp;STR longest&lt;'a&gt;(&amp;'a STR a, &amp;'a STR b) -&gt; &amp;'a STR {\n    IF (a.length() &gt; b.length()) {\n        RETURN a;\n    } ELSE {\n        RETURN b;\n    }\n}\n</code></pre>"},{"location":"reference/language_specification/#10-standard-library","title":"10. Standard Library","text":""},{"location":"reference/language_specification/#101-core-modules","title":"10.1 Core Modules","text":"<ul> <li><code>std.io</code>: Input/output operations</li> <li><code>std.collections</code>: Data structures</li> <li><code>std.time</code>: Time-related functions</li> <li><code>std.math</code>: Mathematical functions</li> <li><code>std.thread</code>: Concurrency primitives</li> </ul>"},{"location":"reference/language_specification/#102-common-types","title":"10.2 Common Types","text":"<ul> <li><code>Option&lt;T&gt;</code>: Represents an optional value</li> <li><code>Result&lt;T,E&gt;</code>: For fallible operations</li> <li><code>Vec&lt;T&gt;</code>: Dynamic array</li> <li><code>HashMap&lt;K,V&gt;</code>: Hash map</li> <li><code>String</code>: UTF-8 string</li> </ul>"},{"location":"reference/language_specification/#11-temporal-programming","title":"11. Temporal Programming","text":""},{"location":"reference/language_specification/#111-timeline-operations","title":"11.1 Timeline Operations","text":"<pre><code>// Create a new timeline\nLET tl = TIMELINE_NEW(\"my_timeline\");\n\n// Add an event\nTIMELINE_ADD_EVENT(tl, NOW() + 1s, \\() {\n    io::println(\"Event fired!\");\n});\n\n// Run the timeline\nTIMELINE_RUN(tl);\n</code></pre>"},{"location":"reference/language_specification/#112-quantum-computing","title":"11.2 Quantum Computing","text":"<pre><code>// Create qubits\nLET q1 = QUBIT(0);\nLET q2 = QUBIT(1);\n\n// Apply quantum gates\nH(q1);  // Hadamard\nCNOT(q1, q2);\n\n// Measure\nLET result = MEASURE(q1);\n</code></pre>"},{"location":"reference/language_specification/#12-implementation-notes","title":"12. Implementation Notes","text":""},{"location":"reference/language_specification/#121-memory-model","title":"12.1 Memory Model","text":"<ul> <li>Stack allocation by default</li> <li>Move semantics for complex types</li> <li>Automatic reference counting for shared ownership</li> <li>No garbage collection pauses</li> </ul>"},{"location":"reference/language_specification/#122-runtime","title":"12.2 Runtime","text":"<ul> <li>Lightweight runtime</li> <li>Zero-cost abstractions</li> <li>Minimal runtime overhead</li> </ul>"},{"location":"reference/language_specification/#13-appendix","title":"13. Appendix","text":""},{"location":"reference/language_specification/#131-keywords","title":"13.1 Keywords","text":"<pre><code>as          break       const       continue    else        enum\nextern      false       fn          for         if          impl\nin          let         loop        match       mod         move\nmut         pub         ref         return      self       Self\nstatic      struct      super       trait       true       type\nunsafe      use         where       while       async      await\ndyn         become      box         do          final      macro\noverride    priv        try         typeof      unsized    virtual\nyield       abstract    const       macro_rules\n</code></pre>"},{"location":"reference/language_specification/#132-operators","title":"13.2 Operators","text":"<pre><code>+    -    *    /    %    ^    !    &amp;    |    &amp;&amp;   ||   &lt;&lt;   &gt;&gt;\n+=   -=   *=   /=   %=   ^=   &amp;=   |=   &lt;&lt;=  &gt;&gt;=  =    ==   !=\n&gt;    &lt;    &gt;=   &lt;=   @    .    ..   ...  ..=   ,    ;    :    ::\n-&gt;   =&gt;   #    $\n</code></pre>"},{"location":"reference/language_specification/#14-references","title":"14. References","text":"<ol> <li>Chronovyan GitHub Repository</li> <li>Temporal Programming Patterns</li> <li>Quantum Computing Basics</li> </ol>"},{"location":"reference/language_specification/#15-license","title":"15. License","text":"<p>Chronovyan is licensed under the MIT License. See LICENSE for details.</p>"}]}