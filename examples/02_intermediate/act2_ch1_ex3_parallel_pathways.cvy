/**
 * @file parallel_pathways.cvy
 * @brief Chronovyan Example: Concurrent Processing & Temporal Streams
 * @difficulty Intermediate
 * @concepts Concurrent Processing, Temporal Threads, Synchronization, Race Conditions
 *
 * This example demonstrates concurrent processing techniques in Chronovyan,
 * showing how to launch and manage multiple temporal threads, prevent
 * race conditions using synchronization primitives, and coordinate
 * dependent operations across concurrent threads.
 *
 * @copyright Chronovyan Project
 */

// Import the standard Chronovyan library
import stdlib.chronovyan;
import stdlib.temporal.threading;

//===============================================================
// Utility Functions
//===============================================================

/**
 * Prints a formatted section header
 * @param title The title of the section
 */
define_pattern print_section_header(title: String) {
    print("\n========== " + title + " ==========\n");
}

//===============================================================
// Part 1: Basic Temporal Threading
//===============================================================

/**
 * Simulates a scan of a specific timeline fragment
 * @param fragment_id The identifier of the fragment to scan
 * @param scan_depth How deep into the fragment to scan
 * @return Data collected from the fragment
 */
define_pattern scan_timeline_fragment(fragment_id: String, scan_depth: Integer) {
    print("Beginning scan of fragment: " + fragment_id);
    
    CONF anomaly_count = 0;
    CONF stability_rating = 0.0;
    
    // Simulate scanning process with a loop
    for (CONF i = 0; i < scan_depth; i++) {
        print("  Fragment " + fragment_id + ": Scanning depth " + i);
        
        // Simulate finding anomalies
        when (random() < 0.3) {
            anomaly_count++;
            print("    Anomaly detected at depth " + i);
        }
        
        // Update stability rating
        stability_rating += (random() * 0.5) + 0.5; // Value between 0.5 and 1.0
        
        // Simulate time passing
        sleep(200);
    }
    
    // Calculate average stability
    CONF avg_stability = stability_rating / scan_depth;
    
    print("Scan complete for fragment: " + fragment_id);
    print("  Anomalies detected: " + anomaly_count);
    print("  Stability rating: " + avg_stability.toFixed(2));
    
    // Return scan results as a structured object
    return {
        fragment: fragment_id,
        anomalies: anomaly_count,
        stability: avg_stability,
        scan_time: scan_depth * 200 // milliseconds
    };
}

/**
 * Demonstrates basic usage of temporal threads
 */
define_pattern demonstrate_basic_threading() {
    print_section_header("Basic Temporal Threading");
    
    print("Launching a single temporal thread to scan fragment Alpha-7");
    
    // Launch the scan as a temporal thread
    CONF thread_id = launch_temporal_thread(scan_timeline_fragment, "Alpha-7", 5);
    print("Scanner thread launched with ID: " + thread_id);
    
    // The main thread continues execution while the temporal thread runs
    print("Main thread continues execution while scan is in progress");
    print("Performing other tasks in the meantime...");
    
    // Check if the thread is complete
    while (!is_thread_complete(thread_id)) {
        print("Waiting for scan to complete...");
        sleep(500); // Check every half second
    }
    
    // Collect the results once the thread is complete
    CONF scan_result = collect_thread_results(thread_id);
    print("Scan results collected:");
    print("  Fragment: " + scan_result.fragment);
    print("  Anomalies: " + scan_result.anomalies);
    print("  Stability: " + scan_result.stability.toFixed(2));
    print("  Scan time: " + scan_result.scan_time + "ms");
    
    print("Basic threading demonstration complete");
    return scan_result;
}

//===============================================================
// Part 2: Multiple Concurrent Threads
//===============================================================

/**
 * Demonstrates launching multiple concurrent threads
 */
define_pattern demonstrate_multiple_threads() {
    print_section_header("Multiple Concurrent Threads");
    
    print("Launching multiple concurrent scanner threads");
    
    // Array to store our thread IDs
    CONF thread_ids = [];
    CONF fragment_names = ["Alpha-3", "Beta-7", "Gamma-2"];
    
    // Launch multiple scanner threads
    for (CONF i = 0; i < fragment_names.length; i++) {
        CONF fragment_id = fragment_names[i];
        CONF scan_depth = 3 + i; // Different depths for different fragments
        
        print("Launching scanner for " + fragment_id + " with depth " + scan_depth);
        CONF thread_id = launch_temporal_thread(scan_timeline_fragment, fragment_id, scan_depth);
        thread_ids.push(thread_id);
    }
    
    print("All scanner threads launched, continuing with main thread");
    print("Monitoring thread completion status...");
    
    // Wait for all threads to complete
    CONF completed_threads = 0;
    while (completed_threads < thread_ids.length) {
        completed_threads = 0;
        
        for (CONF i = 0; i < thread_ids.length; i++) {
            when (is_thread_complete(thread_ids[i])) {
                completed_threads++;
            }
        }
        
        print("  " + completed_threads + " of " + thread_ids.length + " threads complete");
        sleep(500); // Check every half second
    }
    
    print("All scanner threads have completed");
    
    // Collect all results
    CONF all_results = [];
    for (CONF i = 0; i < thread_ids.length; i++) {
        CONF result = collect_thread_results(thread_ids[i]);
        all_results.push(result);
    }
    
    // Process the combined results
    print("Analyzing combined scan results:");
    
    CONF total_anomalies = 0;
    CONF avg_stability = 0.0;
    
    for (CONF result in all_results) {
        print("  Fragment " + result.fragment + ":");
        print("    Anomalies: " + result.anomalies);
        print("    Stability: " + result.stability.toFixed(2));
        
        total_anomalies += result.anomalies;
        avg_stability += result.stability;
    }
    
    avg_stability /= all_results.length;
    
    print("Summary of all scans:");
    print("  Total fragments scanned: " + all_results.length);
    print("  Total anomalies detected: " + total_anomalies);
    print("  Average stability rating: " + avg_stability.toFixed(2));
    
    print("Multiple threading demonstration complete");
    return all_results;
}

//===============================================================
// Part 3: Temporal Dissonance (Race Conditions)
//===============================================================

/**
 * Shared data buffer (simulates the relay station's central data repository)
 */
REB data_buffer = {
    entries: [],
    anomaly_count: 0,
    total_stability: 0.0
};

/**
 * Pattern that adds data to the shared buffer without synchronization
 * This demonstrates a race condition (Temporal Dissonance)
 */
define_pattern add_scan_data_unsafe(scanner_id: String, anomalies: Integer, stability: Float) {
    print("Scanner " + scanner_id + " preparing to add data: " + 
          anomalies + " anomalies, stability " + stability.toFixed(2));
    
    // Simulate some processing time
    sleep(random() * 500);
    
    // Read current values from the buffer
    CONF current_anomaly_count = data_buffer.anomaly_count;
    CONF current_stability = data_buffer.total_stability;
    
    print("Scanner " + scanner_id + " reads current values:");
    print("  Current anomaly count: " + current_anomaly_count);
    print("  Current stability sum: " + current_stability.toFixed(2));
    
    // Simulate more processing time (makes race condition more likely)
    sleep(random() * 500);
    
    // Update the buffer (POTENTIAL RACE CONDITION HERE)
    data_buffer.anomaly_count = current_anomaly_count + anomalies;
    data_buffer.total_stability = current_stability + stability;
    data_buffer.entries.push({
        scanner: scanner_id,
        anomalies: anomalies,
        stability: stability
    });
    
    print("Scanner " + scanner_id + " updated buffer:");
    print("  New anomaly count: " + data_buffer.anomaly_count);
    print("  New stability sum: " + data_buffer.total_stability.toFixed(2));
    
    return true;
}

/**
 * Demonstrates race conditions (Temporal Dissonance)
 */
define_pattern demonstrate_race_condition() {
    print_section_header("Temporal Dissonance (Race Conditions)");
    
    print("Demonstrating race conditions with shared data");
    
    // Reset the buffer
    data_buffer.entries = [];
    data_buffer.anomaly_count = 0;
    data_buffer.total_stability = 0.0;
    
    // Launch multiple threads that will all try to update the buffer
    CONF scanner_threads = [];
    CONF expected_anomalies = 0;
    CONF expected_stability = 0.0;
    
    // Create data for each scanner
    CONF scanner_data = [
        { id: "Alpha-Scanner", anomalies: 3, stability: 0.85 },
        { id: "Beta-Scanner", anomalies: 1, stability: 0.92 },
        { id: "Gamma-Scanner", anomalies: 5, stability: 0.78 },
        { id: "Delta-Scanner", anomalies: 0, stability: 0.99 },
        { id: "Epsilon-Scanner", anomalies: 2, stability: 0.88 }
    ];
    
    // Launch threads and track expected totals
    for (CONF data in scanner_data) {
        print("Launching " + data.id + " with data:");
        print("  Anomalies: " + data.anomalies);
        print("  Stability: " + data.stability.toFixed(2));
        
        CONF thread_id = launch_temporal_thread(
            add_scan_data_unsafe, 
            data.id, 
            data.anomalies, 
            data.stability
        );
        scanner_threads.push(thread_id);
        
        // Track what the expected totals should be
        expected_anomalies += data.anomalies;
        expected_stability += data.stability;
    }
    
    // Wait for all threads to complete
    CONF all_complete = false;
    while (!all_complete) {
        all_complete = true;
        for (CONF id in scanner_threads) {
            if (!is_thread_complete(id)) {
                all_complete = false;
                break;
            }
        }
        sleep(200);
    }
    
    // Check if the totals match what we expect
    print("All scanner threads have completed");
    print("Checking for Temporal Dissonance (race conditions):");
    print("  Expected anomaly count: " + expected_anomalies);
    print("  Actual anomaly count: " + data_buffer.anomaly_count);
    print("  Expected stability sum: " + expected_stability.toFixed(2));
    print("  Actual stability sum: " + data_buffer.total_stability.toFixed(2));
    
    CONF has_dissonance = false;
    
    if (expected_anomalies != data_buffer.anomaly_count) {
        print("TEMPORAL DISSONANCE DETECTED: Anomaly counts don't match!");
        has_dissonance = true;
    }
    
    if (Math.abs(expected_stability - data_buffer.total_stability) > 0.001) {
        print("TEMPORAL DISSONANCE DETECTED: Stability sums don't match!");
        has_dissonance = true;
    }
    
    if (!has_dissonance) {
        print("No temporal dissonance detected. (Note: This might be luck - run again to see if it fails)");
    }
    
    print("Race condition demonstration complete");
    return has_dissonance;
}

//===============================================================
// Part 4: Harmony Crystals (Mutexes)
//===============================================================

/**
 * Define a Harmony Crystal for the data buffer
 */
CONF buffer_crystal = "data_buffer_crystal";

/**
 * Pattern that adds data to the shared buffer WITH synchronization
 * Uses a Harmony Crystal to prevent race conditions
 */
define_pattern add_scan_data_safe(scanner_id: String, anomalies: Integer, stability: Float) {
    print("Scanner " + scanner_id + " preparing to add data: " + 
          anomalies + " anomalies, stability " + stability.toFixed(2));
    
    // Simulate some processing time
    sleep(random() * 500);
    
    // Claim the Harmony Crystal to protect the critical section
    print("Scanner " + scanner_id + " is claiming the Harmony Crystal...");
    claim_harmony_crystal(buffer_crystal);
    print("Scanner " + scanner_id + " has claimed the Harmony Crystal");
    
    // CRITICAL SECTION - Protected by the Harmony Crystal
    // Read current values from the buffer
    CONF current_anomaly_count = data_buffer.anomaly_count;
    CONF current_stability = data_buffer.total_stability;
    
    print("Scanner " + scanner_id + " reads current values:");
    print("  Current anomaly count: " + current_anomaly_count);
    print("  Current stability sum: " + current_stability.toFixed(2));
    
    // Simulate more processing time
    sleep(random() * 500);
    
    // Update the buffer (NOW PROTECTED FROM RACE CONDITIONS)
    data_buffer.anomaly_count = current_anomaly_count + anomalies;
    data_buffer.total_stability = current_stability + stability;
    data_buffer.entries.push({
        scanner: scanner_id,
        anomalies: anomalies,
        stability: stability
    });
    
    print("Scanner " + scanner_id + " updated buffer:");
    print("  New anomaly count: " + data_buffer.anomaly_count);
    print("  New stability sum: " + data_buffer.total_stability.toFixed(2));
    // END CRITICAL SECTION
    
    // Release the Harmony Crystal
    print("Scanner " + scanner_id + " is releasing the Harmony Crystal");
    release_harmony_crystal(buffer_crystal);
    
    return true;
}

/**
 * Demonstrates using Harmony Crystals to prevent race conditions
 */
define_pattern demonstrate_harmony_crystals() {
    print_section_header("Harmony Crystals (Mutexes)");
    
    print("Demonstrating synchronization with Harmony Crystals");
    
    // Reset the buffer
    data_buffer.entries = [];
    data_buffer.anomaly_count = 0;
    data_buffer.total_stability = 0.0;
    
    // Launch multiple threads that will all try to update the buffer
    CONF scanner_threads = [];
    CONF expected_anomalies = 0;
    CONF expected_stability = 0.0;
    
    // Create data for each scanner
    CONF scanner_data = [
        { id: "Alpha-Scanner", anomalies: 3, stability: 0.85 },
        { id: "Beta-Scanner", anomalies: 1, stability: 0.92 },
        { id: "Gamma-Scanner", anomalies: 5, stability: 0.78 },
        { id: "Delta-Scanner", anomalies: 0, stability: 0.99 },
        { id: "Epsilon-Scanner", anomalies: 2, stability: 0.88 }
    ];
    
    // Launch threads and track expected totals
    for (CONF data in scanner_data) {
        print("Launching " + data.id + " with data:");
        print("  Anomalies: " + data.anomalies);
        print("  Stability: " + data.stability.toFixed(2));
        
        CONF thread_id = launch_temporal_thread(
            add_scan_data_safe, 
            data.id, 
            data.anomalies, 
            data.stability
        );
        scanner_threads.push(thread_id);
        
        // Track what the expected totals should be
        expected_anomalies += data.anomalies;
        expected_stability += data.stability;
    }
    
    // Wait for all threads to complete
    CONF all_complete = false;
    while (!all_complete) {
        all_complete = true;
        for (CONF id in scanner_threads) {
            if (!is_thread_complete(id)) {
                all_complete = false;
                break;
            }
        }
        sleep(200);
    }
    
    // Check if the totals match what we expect
    print("All scanner threads have completed");
    print("Checking for Temporal Dissonance (race conditions):");
    print("  Expected anomaly count: " + expected_anomalies);
    print("  Actual anomaly count: " + data_buffer.anomaly_count);
    print("  Expected stability sum: " + expected_stability.toFixed(2));
    print("  Actual stability sum: " + data_buffer.total_stability.toFixed(2));
    
    CONF has_dissonance = false;
    
    if (expected_anomalies != data_buffer.anomaly_count) {
        print("TEMPORAL DISSONANCE DETECTED: Anomaly counts don't match!");
        has_dissonance = true;
    }
    
    if (Math.abs(expected_stability - data_buffer.total_stability) > 0.001) {
        print("TEMPORAL DISSONANCE DETECTED: Stability sums don't match!");
        has_dissonance = true;
    }
    
    if (!has_dissonance) {
        print("Harmony maintained! The totals match exactly as expected.");
    }
    
    print("Harmony Crystal demonstration complete");
    return !has_dissonance;
}

//===============================================================
// Part 5: Signal Glyphs (Signaling Between Threads)
//===============================================================

// Signal Glyphs for coordinating between threads
CONF scan_complete_glyph = "scan_complete_signal";
CONF analysis_complete_glyph = "analysis_complete_signal";
CONF mapping_complete_glyph = "mapping_complete_signal";

/**
 * Simulates the initial scan of temporal surroundings
 */
define_pattern initial_scan() {
    print("Beginning initial scan of temporal surroundings...");
    
    // Simulate scanning process
    CONF scan_time = 1000 + Math.floor(random() * 500);
    sleep(scan_time);
    
    CONF result = {
        scan_duration: scan_time,
        raw_data_points: Math.floor(random() * 100) + 50,
        scan_timestamp: current_timestamp()
    };
    
    print("Initial scan complete with " + result.raw_data_points + " data points");
    print("Activating scan_complete signal glyph");
    
    // Signal that the scan is complete
    activate_signal_glyph(scan_complete_glyph);
    
    return result;
}

/**
 * Simulates the analysis of scan data
 * This pattern waits for the scan to complete before starting
 */
define_pattern analyze_scan_data() {
    print("Analysis thread started, waiting for initial scan to complete...");
    
    // Wait for the scan to complete before proceeding
    wait_for_signal_glyph(scan_complete_glyph);
    
    print("Scan complete signal received, beginning analysis...");
    
    // Simulate analysis process
    CONF analysis_time = 800 + Math.floor(random() * 400);
    sleep(analysis_time);
    
    CONF result = {
        analysis_duration: analysis_time,
        anomalies_identified: Math.floor(random() * 10) + 1,
        stability_index: (random() * 0.3) + 0.7, // 0.7 to 1.0
        analysis_timestamp: current_timestamp()
    };
    
    print("Analysis complete. Identified " + result.anomalies_identified + 
          " anomalies with stability index " + result.stability_index.toFixed(2));
    print("Activating analysis_complete signal glyph");
    
    // Signal that the analysis is complete
    activate_signal_glyph(analysis_complete_glyph);
    
    return result;
}

/**
 * Simulates the generation of navigation maps
 * This pattern waits for the analysis to complete before starting
 */
define_pattern generate_maps() {
    print("Mapping thread started, waiting for analysis to complete...");
    
    // Wait for the analysis to complete before proceeding
    wait_for_signal_glyph(analysis_complete_glyph);
    
    print("Analysis complete signal received, generating navigation maps...");
    
    // Simulate mapping process
    CONF mapping_time = 500 + Math.floor(random() * 300);
    sleep(mapping_time);
    
    CONF result = {
        mapping_duration: mapping_time,
        safe_routes_found: Math.floor(random() * 3) + 1,
        mapping_timestamp: current_timestamp()
    };
    
    print("Maps generated successfully with " + 
          result.safe_routes_found + " safe route(s) identified");
    print("Activating mapping_complete signal glyph");
    
    // Signal that the mapping is complete
    activate_signal_glyph(mapping_complete_glyph);
    
    return result;
}

/**
 * Demonstrates using Signal Glyphs to coordinate dependent operations
 */
define_pattern demonstrate_signal_glyphs() {
    print_section_header("Signal Glyphs (Thread Coordination)");
    
    print("Demonstrating coordination between dependent threads using Signal Glyphs");
    
    // Reset signal glyphs (in case they were activated in a previous run)
    reset_signal_glyph(scan_complete_glyph);
    reset_signal_glyph(analysis_complete_glyph);
    reset_signal_glyph(mapping_complete_glyph);
    
    print("Launching all three threads concurrently:");
    print("  1. Initial scan thread");
    print("  2. Analysis thread (waits for scan to complete)");
    print("  3. Mapping thread (waits for analysis to complete)");
    
    // Launch all three threads concurrently
    CONF scan_thread = launch_temporal_thread(initial_scan);
    CONF analysis_thread = launch_temporal_thread(analyze_scan_data);
    CONF mapping_thread = launch_temporal_thread(generate_maps);
    
    print("All threads launched, monitoring progress...");
    
    // Wait for all threads to complete
    while (!is_thread_complete(scan_thread) || 
           !is_thread_complete(analysis_thread) || 
           !is_thread_complete(mapping_thread)) {
        
        // Print status of each thread
        print("Thread status:");
        print("  Scan thread: " + 
              (is_thread_complete(scan_thread) ? "COMPLETE" : "RUNNING"));
        print("  Analysis thread: " + 
              (is_thread_complete(analysis_thread) ? "COMPLETE" : 
               (is_signal_glyph_active(scan_complete_glyph) ? "RUNNING" : "WAITING")));
        print("  Mapping thread: " + 
              (is_thread_complete(mapping_thread) ? "COMPLETE" : 
               (is_signal_glyph_active(analysis_complete_glyph) ? "RUNNING" : "WAITING")));
        
        sleep(500);
    }
    
    // Collect all results
    CONF scan_result = collect_thread_results(scan_thread);
    CONF analysis_result = collect_thread_results(analysis_thread);
    CONF mapping_result = collect_thread_results(mapping_thread);
    
    // Calculate total processing time
    CONF total_time = scan_result.scan_duration + 
                      analysis_result.analysis_duration + 
                      mapping_result.mapping_duration;
    
    CONF parallel_time = Math.max(
        scan_result.scan_duration,
        analysis_result.analysis_duration + mapping_result.mapping_duration
    );
    
    CONF time_saved = total_time - parallel_time;
    CONF efficiency_gain = (time_saved / total_time * 100).toFixed(1);
    
    print("All operations complete!");
    print("Processing summary:");
    print("  Sequential processing time would be: " + total_time + "ms");
    print("  Parallel processing time was: " + parallel_time + "ms");
    print("  Time saved through concurrent processing: " + time_saved + "ms (" + efficiency_gain + "%)");
    print("Result summary:");
    print("  Data points collected: " + scan_result.raw_data_points);
    print("  Anomalies identified: " + analysis_result.anomalies_identified);
    print("  Stability index: " + analysis_result.stability_index.toFixed(2));
    print("  Safe routes mapped: " + mapping_result.safe_routes_found);
    
    print("Signal Glyph demonstration complete");
    return {
        scan: scan_result,
        analysis: analysis_result,
        mapping: mapping_result,
        efficiency_gain: parseFloat(efficiency_gain)
    };
}

//===============================================================
// Utility Functions
//===============================================================

/**
 * Returns the current timestamp (simulation)
 */
define_pattern current_timestamp() {
    return Date.now();
}

//===============================================================
// Main Demonstration
//===============================================================

/**
 * Main function that demonstrates all concurrent processing concepts
 */
define_pattern main() {
    print_section_header("Chronovyan Temporal Threading Demonstration");
    print("This example demonstrates concurrent processing and synchronization techniques in Chronovyan.");
    
    // Part 1: Basic Temporal Threading
    demonstrate_basic_threading();
    
    // Part 2: Multiple Concurrent Threads
    demonstrate_multiple_threads();
    
    // Part 3: Race Conditions (Temporal Dissonance)
    CONF has_dissonance = demonstrate_race_condition();
    
    // Part 4: Harmony Crystals (Mutexes)
    CONF harmony_maintained = demonstrate_harmony_crystals();
    
    // Part 5: Signal Glyphs (Signaling)
    CONF signal_results = demonstrate_signal_glyphs();
    
    // Final summary
    print_section_header("Demonstration Summary");
    print("You have successfully mastered concurrent temporal processing!");
    print("Key concepts demonstrated:");
    print("  1. Launching and managing temporal threads");
    print("  2. Running multiple concurrent operations");
    print("  3. Identifying and resolving race conditions using Harmony Crystals");
    print("  4. Coordinating dependent operations using Signal Glyphs");
    
    print("Congratulations! The relay station is now fully operational.");
    print("The temporal map generated will guide your expedition safely through the unstable regions ahead.");
    
    return {
        race_conditions_observed: has_dissonance,
        harmony_maintained: harmony_maintained,
        efficiency_gain: signal_results.efficiency_gain,
        safe_routes_found: signal_results.mapping.safe_routes_found
    };
}

// Run the main demonstration
main(); 