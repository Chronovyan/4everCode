/*
  ____        _        _ _  ___   
 |  _ \ _   _| | ___  / / |/ _ \  
 | |_) | | | | |/ _ \/ /| | | | | 
 |  _ <| |_| | |  __/ / | | |_| | 
 |_| \_\\__,_|_|\___/_/  |_|\___/ 
                                 
 Cellular Automaton Simulation
*/

// Rule 110 Simulation (03_advanced/01_rule110_simulation.cvy)
// This file demonstrates an implementation of the Rule 110 cellular automaton
// using Chronovyan's temporal features for parallel processing.
//
// Expected output: A visual pattern of Rule 110 cellular automaton evolution
// showing the characteristic triangular patterns that emerge over generations.
// Rule 110 is notable for being proven to be Turing-complete.

// Import required libraries
import "chrono.core";
import "chrono.visual";
import "chrono.temporal";

// Configuration options (can be modified for different effects)
var CONF world_size = 31;         // Size of the cellular world
var CONF generations = 20;        // Number of generations to simulate
var CONF use_color = true;        // Use colored output if supported
var CONF display_delay = 100;     // Milliseconds between generations
var CONF wrap_edges = true;       // Whether edges wrap around

// Display character options
var live_cell_char = "â– ";
var dead_cell_char = " ";
var REB live_cell_color = "cyan"; // REB variable allows color to shift across timelines

// Initialize a world (array of cells)
func initialize_world() {
    var world = new Array(world_size);
    
    // Initialize with a single live cell in the middle
    for (var i = 0; i < world_size; i++) {
        world[i] = 0;
    }
    
    // Set middle cell alive (or can use random pattern with SET_RANDOM_SEED)
    world[Math.floor(world_size / 2)] = 1;
    
    return world;
}

// Display the current state of the world
func display_world(world, generation) {
    var display = "";
    
    // Generate the display string
    for (var i = 0; i < world.length; i++) {
        if (use_color && world[i] == 1) {
            // Use colored output if enabled
            display += visual.colored_text(live_cell_char, live_cell_color);
        } else {
            display += world[i] == 1 ? live_cell_char : dead_cell_char;
        }
    }
    
    // Print the current generation
    print("Gen " + generation.toString().padStart(2, '0') + ": " + display);
    
    // Add delay between generations for visual effect
    if (display_delay > 0) {
        temporal.delay(display_delay);
    }
}

// Apply Rule 110 to a cell based on its neighborhood
func apply_rule110(left, center, right) {
    // Rule 110 is a specific cellular automaton rule with the following transitions:
    // 111 -> 0 : If all three cells are alive, the center cell dies
    // 110 -> 1 : If left and center are alive, right is dead, center stays alive
    // 101 -> 1 : If left and right are alive, center is dead, center becomes alive
    // 100 -> 0 : If only left is alive, center stays/becomes dead
    // 011 -> 1 : If center and right are alive, left is dead, center stays alive
    // 010 -> 1 : If only center is alive, it stays alive
    // 001 -> 1 : If only right is alive, center becomes alive
    // 000 -> 0 : If all cells are dead, center stays dead
    
    // The rule can be compactly represented as binary: 01101110 (0x6E)
    var pattern = (left << 2) | (center << 1) | right;
    return (0x6E >> pattern) & 1;
}

// Advanced implementation: Process multiple cells in parallel timelines
func simulate_generation_parallel(world) {
    var new_world = new Array(world.length);
    var segment_size = Math.ceil(world.length / 3);  // Split into 3 segments
    
    // Use temporal branching to process segments in parallel
    temporal branch(3) {
        var branch_id = temporal.current_branch();
        var start = branch_id * segment_size;
        var end = Math.min(start + segment_size, world.length);
        
        // Process this segment
        for (var i = start; i < end; i++) {
            // Get the three cells (with wrap-around if enabled)
            var left, right;
            
            if (wrap_edges) {
                left = (i == 0) ? world[world.length - 1] : world[i - 1];
                right = (i == world.length - 1) ? world[0] : world[i + 1];
            } else {
                left = (i == 0) ? 0 : world[i - 1];
                right = (i == world.length - 1) ? 0 : world[i + 1];
            }
            
            var center = world[i];
            
            // Apply the rule
            new_world[i] = apply_rule110(left, center, right);
        }
        
        // Synchronize all branches
        temporal.sync();
    }
    
    return new_world;
}

// Standard sequential implementation
func simulate_generation(world) {
    var new_world = new Array(world.length);
    
    // Apply Rule 110 to each cell
    for (var i = 0; i < world.length; i++) {
        // Get the three cells (with wrap-around if enabled)
        var left, right;
        
        if (wrap_edges) {
            left = (i == 0) ? world[world.length - 1] : world[i - 1];
            right = (i == world.length - 1) ? world[0] : world[i + 1];
        } else {
            left = (i == 0) ? 0 : world[i - 1];
            right = (i == world.length - 1) ? 0 : world[i + 1];
        }
        
        var center = world[i];
        
        // Apply the rule
        new_world[i] = apply_rule110(left, center, right);
    }
    
    return new_world;
}

// Analyze emergent patterns in the cellular automaton
func analyze_patterns(world_history) {
    print("\n=== Pattern Analysis ===");
    
    // Look for common Rule 110 patterns
    var triangles_detected = 0;
    var gliders_detected = 0;
    
    // Simple detection of triangular patterns
    for (var g = 5; g < world_history.length; g++) {
        for (var i = 2; i < world_history[g].length - 2; i++) {
            // Check for triangular pattern
            if (!world_history[g-2][i-2] && world_history[g-2][i-1] && world_history[g-2][i] && 
                !world_history[g-1][i-1] && world_history[g-1][i] && 
                !world_history[g][i]) {
                triangles_detected++;
            }
            
            // Check for glider-like pattern
            if (!world_history[g-4][i-2] && world_history[g-4][i-1] && 
                world_history[g-3][i] && !world_history[g-2][i] && 
                world_history[g-1][i+1] && world_history[g][i+2]) {
                gliders_detected++;
            }
        }
    }
    
    print("Detected " + triangles_detected + " triangle patterns");
    print("Detected " + gliders_detected + " glider-like patterns");
    print("========================");
}

// Main function
func main() {
    // Display header
    print("=== Rule 110 Cellular Automaton Simulation ===");
    print("Rule 110 is known to be Turing-complete");
    print("Watch for the emergence of complex triangular patterns");
    print("");
    
    // Initialize the world
    var world = initialize_world();
    var world_history = [world.slice()];  // Keep track of all generations for analysis
    
    // Display the initial state
    display_world(world, 0);
    
    // Track processing time for both methods
    var sequential_time = 0;
    var parallel_time = 0;
    
    // Simulate for the specified number of generations
    for (var gen = 1; gen <= generations; gen++) {
        // Alternate between sequential and parallel processing to compare
        if (gen % 2 == 0) {
            // Use sequential processing for even generations
            var start_time = chrono.core.now();
            world = simulate_generation(world);
            var end_time = chrono.core.now();
            sequential_time += (end_time - start_time);
        } else {
            // Use parallel processing for odd generations
            var start_time = chrono.core.now();
            world = simulate_generation_parallel(world);
            var end_time = chrono.core.now();
            parallel_time += (end_time - start_time);
        }
        
        // Save this generation for pattern analysis
        world_history.push(world.slice());
        
        // Display the current generation
        display_world(world, gen);
        
        // Create a temporal branch every 5 generations
        // This demonstrates how Chronovyan can create parallel simulations
        if (gen % 5 == 0) {
            temporal branch(2) {
                var branch_id = temporal.current_branch();
                if (branch_id == 1) {
                    // In the alternate timeline, change the color
                    live_cell_color = "magenta";
                    print("Timeline branch: Color shifted");
                }
            }
        }
    }
    
    // Analyze the patterns that emerged
    analyze_patterns(world_history);
    
    // Compare processing methods
    print("\n=== Performance Comparison ===");
    print("Sequential processing time: " + sequential_time);
    print("Parallel processing time: " + parallel_time);
    print("Speedup factor: " + (sequential_time / parallel_time).toFixed(2) + "x");
    
    // Final output
    print("");
    print("Simulation complete");
    print("To run with different parameters, modify the configuration options at the top");
    
    return 0;
} 