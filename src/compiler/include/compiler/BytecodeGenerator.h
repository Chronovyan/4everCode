#ifndef CHRONOVYAN_COMPILER_BYTECODE_GENERATOR_H
#define CHRONOVYAN_COMPILER_BYTECODE_GENERATOR_H

#include <memory>
#include <stack>
#include <string>
#include <unordered_map>
#include <vector>

#include "compiler/AstVisitor.h"
#include "compiler/Diagnostic.h"
#include "compiler/IR.h"
#include "compiler/bytecode/BytecodeModule.h"

namespace chronovyan {
namespace compiler {

/**
 * @brief Generates bytecode from an IR program
 */
class BytecodeGenerator {
public:
    /**
     * @brief Constructor
     * @param diagnostics Diagnostic reporter for reporting errors
     */
    explicit BytecodeGenerator(DiagnosticReporter& diagnostics);

    /**
     * @brief Generate bytecode from IR
     * @param irProgram The IR program
     * @return The generated bytecode module
     */
    bytecode::BytecodeModule generateBytecode(const IRProgram& irProgram);

private:
    /**
     * @brief Generate bytecode for a single instruction
     * @param function The bytecode function to add instructions to
     * @param instruction The IR instruction
     * @param labelOffsets Map of label to bytecode offset
     */
    void generateInstructionForFunction(
        std::shared_ptr<bytecode::BytecodeFunction> function, const IRInstruction& instruction,
        const std::unordered_map<std::string, size_t>& labelOffsets);

    /**
     * @brief Handle temporal operations in bytecode
     * @param function The bytecode function to add instructions to
     * @param instruction The IR instruction for a temporal operation
     */
    void handleTemporalOperation(std::shared_ptr<bytecode::BytecodeFunction> function,
                                 const IRInstruction& instruction);

    /**
     * @brief Convert an IR value to a bytecode constant
     * @param value The IR value
     * @return The bytecode constant
     */
    bytecode::BytecodeConstant convertIRValueToConstant(const IRValue& value);

    /**
     * @brief Add a constant to the constant pool
     * @param constant The constant to add
     * @return The index of the constant in the pool
     */
    size_t addConstant(const bytecode::BytecodeConstant& constant);

    /**
     * @brief Generate a unique label with the given prefix
     * @param prefix Label prefix
     * @return A unique label string
     */
    std::string generateLabel(const std::string& prefix);

    /**
     * @brief Calculate the stack effect of an instruction
     * @param instruction The IR instruction
     * @return The net effect on the stack (positive for push, negative for pop)
     */
    int calculateStackEffect(const IRInstruction& instruction);

    // Fields
    DiagnosticReporter& diagnostics;                       ///< Diagnostic reporter
    std::vector<bytecode::BytecodeConstant> constantPool;  ///< Constant pool
    int labelCounter;                                      ///< Counter for generating unique labels
    bool hasError;  ///< Whether an error occurred during generation
};

}  // namespace compiler
}  // namespace chronovyan

#endif  // CHRONOVYAN_COMPILER_BYTECODE_GENERATOR_H