/*
 ____  _                                              
/  __\| |__  _ __ ___  _ __   _____   ___   __ _ _ __  
| /   |  _ \| '__/ _ \| '_ \ / _ \ \ / / | | | '_  \/ _ \ 
| \__ | | | | | | (_) | | | | (_) \ V /| |_| | | | |  __/ 
\____|_| |_|_|  \___/|_| |_|\___/ \_/  \__, |_| |_|\___| 
                                       |___/             
*/

// Automatic Resource Optimizer Demo
// This script demonstrates how the automatic resource optimizer can improve resource usage
// in Chronovyan applications by detecting patterns and automatically applying optimizations.

// Import standard libraries
import "chrono.core";
import "chrono.resources";
import "chrono.visualization";

// Function to simulate an operation with different patterns
func simulateOperation(operation_id::CONF_STRING, pattern::CONF_STRING, iterations::CONF_INT) {
    print("Simulating " + pattern + " pattern for operation " + operation_id);
    
    CONF_INT base_chronons = 100;
    CONF_INT i;
    
    for (i = 0; i < iterations; i++) {
        // Determine resource amount based on pattern
        CONF_INT amount = base_chronons;
        
        if (pattern == "repetitive") {
            // Consistent usage
            amount = base_chronons;
        } else if (pattern == "spike") {
            // Occasional high usage
            if (i % 3 == 0) {
                amount = base_chronons * 3;
            }
        } else if (pattern == "cyclic") {
            // Alternating usage
            if (i % 2 == 0) {
                amount = base_chronons * 1.5;
            } else {
                amount = base_chronons * 0.5;
            }
        } else if (pattern == "increasing") {
            // Steadily increasing usage
            amount = base_chronons + (i * 10);
        } else if (pattern == "decreasing") {
            // Steadily decreasing usage
            amount = base_chronons * 2 - (i * 10);
            if (amount < 10) amount = 10;
        }
        
        // Perform the operation (consumes resources)
        print("  Iteration " + i + ": Using " + amount + " chronons");
        EXPEND_RESOURCES(amount / 2, amount);
        
        // Optimize the operation (optional, but helps the optimizer learn)
        OPTIMIZE_CHRONONS(operation_id);
    }
}

// Main function
func main() {
    print("=== Automatic Resource Optimizer Demo ===");
    
    // Initialize resources
    CONF_INT initial_chronons = 5000;
    CONF_INT initial_aethel = 2500;
    
    SET_CHRONONS_LEVEL(initial_chronons);
    SET_AETHEL_LEVEL(initial_aethel);
    
    print("Initial resources:");
    print("  Chronons: " + GET_CHRONONS_LEVEL());
    print("  Aethel: " + GET_AETHEL_LEVEL());
    
    // Configure the automatic optimizer
    print("\nConfiguring automatic resource optimizer...");
    AUTO_OPTIMIZE_CONFIG("monitoring_interval", "5");          // Check every 5 seconds
    AUTO_OPTIMIZE_CONFIG("min_improvement", "0.05");           // 5% minimum improvement
    AUTO_OPTIMIZE_CONFIG("max_optimizations_per_cycle", "3");  // Max 3 optimizations per cycle
    AUTO_OPTIMIZE_CONFIG("bottleneck_threshold", "0.3");       // Trigger at 30% resources
    
    // Register a callback for optimization events
    AUTO_OPTIMIZE_REGISTER_CALLBACK();
    
    // Start automatic optimization
    print("Starting automatic optimization...");
    AUTO_OPTIMIZE_START();
    
    // Simulate operations with different patterns
    print("\n=== Simulating Operations with Different Patterns ===");
    simulateOperation("repetitive_operation", "repetitive", 5);
    simulateOperation("spike_operation", "spike", 5);
    simulateOperation("cyclic_operation", "cyclic", 6);
    simulateOperation("increasing_operation", "increasing", 5);
    simulateOperation("decreasing_operation", "decreasing", 5);
    
    print("\nCurrent resources after simulations:");
    print("  Chronons: " + GET_CHRONONS_LEVEL());
    print("  Aethel: " + GET_AETHEL_LEVEL());
    
    // Generate a report of optimization opportunities
    print("\n=== Optimization Opportunities ===");
    CONF_MAP opportunities = IDENTIFY_OPTIMIZATION_OPPORTUNITIES();
    
    if (MAP_SIZE(opportunities) == 0) {
        print("No optimization opportunities identified.");
    } else {
        print("Identified " + MAP_SIZE(opportunities) + " optimization opportunities:");
        
        CONF_LIST operations = MAP_KEYS(opportunities);
        CONF_INT i;
        
        for (i = 0; i < LIST_SIZE(operations); i++) {
            CONF_STRING operation = LIST_GET(operations, i);
            CONF_FLOAT factor = MAP_GET(opportunities, operation);
            CONF_FLOAT savings = (1.0 - factor) * 100.0;
            
            print((i+1) + ". Operation: " + operation);
            print("   Potential savings: " + FORMAT_FLOAT(savings, 1) + "%");
        }
    }
    
    // Perform a manual optimization cycle
    print("\n=== Manual Optimization Cycle ===");
    print("Before optimization cycle:");
    print("  Chronons: " + GET_CHRONONS_LEVEL());
    print("  Aethel: " + GET_AETHEL_LEVEL());
    
    CONF_INT optimizations = PERFORM_OPTIMIZATION_CYCLE();
    print("Performed " + optimizations + " optimizations.");
    
    print("After optimization cycle:");
    print("  Chronons: " + GET_CHRONONS_LEVEL());
    print("  Aethel: " + GET_AETHEL_LEVEL());
    
    // Create a resource bottleneck to trigger automatic optimization
    print("\n=== Creating Resource Bottleneck ===");
    print("Before bottleneck:");
    print("  Chronons: " + GET_CHRONONS_LEVEL());
    
    CONF_INT to_consume = GET_CHRONONS_LEVEL() * 0.8;  // Consume 80% of chronons
    print("Consuming " + to_consume + " chronons...");
    EXPEND_RESOURCES(0, to_consume);
    
    print("After bottleneck:");
    print("  Chronons: " + GET_CHRONONS_LEVEL());
    
    print("\nWaiting for automatic optimization to trigger...");
    SLEEP(6);  // Wait for automatic optimization to trigger
    
    print("Current resources after automatic optimization:");
    print("  Chronons: " + GET_CHRONONS_LEVEL());
    print("  Aethel: " + GET_AETHEL_LEVEL());
    
    // Generate optimization report
    print("\n=== Optimization Report ===");
    CONF_STRING report = GENERATE_OPTIMIZATION_REPORT();
    print(report);
    
    // Clean up
    print("\nStopping automatic optimization...");
    AUTO_OPTIMIZE_STOP();
    
    print("\n=== Demo Complete ===");
}

// Helper function to format a float with specified decimal places
func FORMAT_FLOAT(value::CONF_FLOAT, decimals::CONF_INT) -> CONF_STRING {
    // Simple implementation - would be more sophisticated in actual library
    return value + "";  // Basic conversion to string
} 